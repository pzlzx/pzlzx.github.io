

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/71F99186DE853565BD6D63B7E365DF93.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="通过netlinker和svc获取mac地址解析参考🔗：参考：https:&#x2F;&#x2F;bbs.kanxue.com&#x2F;thread-271698.htm  Unix&#x2F;Linux编程：Netlink机制_unix netlink.h-CSDN博客 杂谈太久没更新博客了，上年纪了（bushi）感觉又想多记录下自己平时的学习过程，最近也找到实习了，感觉自己在业务方面还有很多要进步的地方（他们怎么都那么">
<meta property="og:type" content="article">
<meta property="og:title" content="通过netlinker和svc获取mac地址解析">
<meta property="og:url" content="http://example.com/2025/05/30/netlinker/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="通过netlinker和svc获取mac地址解析参考🔗：参考：https:&#x2F;&#x2F;bbs.kanxue.com&#x2F;thread-271698.htm  Unix&#x2F;Linux编程：Netlink机制_unix netlink.h-CSDN博客 杂谈太久没更新博客了，上年纪了（bushi）感觉又想多记录下自己平时的学习过程，最近也找到实习了，感觉自己在业务方面还有很多要进步的地方（他们怎么都那么">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="d:\%E9%A2%98%E7%9B%AE\deepseek_mermaid_20250530_d8094a.png">
<meta property="og:image" content="d:\%E9%A2%98%E7%9B%AE\deepseek_mermaid_20250530_136373.png">
<meta property="article:published_time" content="2025-05-30T14:38:50.644Z">
<meta property="article:modified_time" content="2025-05-30T14:53:54.615Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="d:\%E9%A2%98%E7%9B%AE\deepseek_mermaid_20250530_d8094a.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>通过netlinker和svc获取mac地址解析 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"\\img\\A008779F61D12BE23A64C76080892F5C.jpg","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  



  
<meta name="generator" content="Hexo 7.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>wwzx blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/EF13D2BBFB766BCFD972CC883B67E7AB.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="通过netlinker和svc获取mac地址解析"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-05-30 22:38" pubdate>
          2025年5月30日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          6.3k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          53 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">通过netlinker和svc获取mac地址解析</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="通过netlinker和svc获取mac地址解析"><a href="#通过netlinker和svc获取mac地址解析" class="headerlink" title="通过netlinker和svc获取mac地址解析"></a>通过netlinker和svc获取mac地址解析</h1><p>参考🔗：参考：<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-271698.htm">https://bbs.kanxue.com/thread-271698.htm</a> </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhizhengguan/article/details/120448337">Unix&#x2F;Linux编程：Netlink机制_unix netlink.h-CSDN博客</a></p>
<h1 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h1><p>太久没更新博客了，上年纪了（bushi）感觉又想多记录下自己平时的学习过程，最近也找到实习了，感觉自己在业务方面还有很多要进步的地方（他们怎么都那么厉害TT），菜就多多多多练，以此共勉，希望能持续更下去</p>
<p>免责声明：主要是记录下自己学习的思路，很乱很杂（）仅自我记录（别喷我别喷我，疯狂叠甲）</p>
<h1 id="导语以及系统相关API函数介绍"><a href="#导语以及系统相关API函数介绍" class="headerlink" title="导语以及系统相关API函数介绍"></a>导语以及系统相关API函数介绍</h1><p>在获取指纹时，我们传统的获取方法是直接使用与安卓系统的属性系统交互的API，例如system_property_get , system_property_find , system_property_read。这些函数用于获取、查找和读取设备的系统属性值。<br>Android 系统属性系统是一个键值对存储，允许开发者在应用或系统级别获取和设置设备的一些配置信息，如设备的 ID、版本号、型号等。这个系统属性数据库类似于 Linux 系统的 <code>/proc</code> 文件系统，但它更加高效并且适用于 Android 的需求。</p>
<h2 id="system-property-get："><a href="#system-property-get：" class="headerlink" title="system_property_get："></a><strong>system_property_get：</strong></h2><p><code>system_property_get</code> 是最常用的一个函数，它用于获取一个系统属性的值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">system_property_get</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">char</span> *value)</span>;<br></code></pre></td></tr></table></figure>

<ul>
<li>**<code>name</code>**：要获取的系统属性的名称。</li>
<li>**<code>value</code>**：系统属性的值，将会存储在这个字符数组中。</li>
<li><strong>返回值</strong>：返回属性的长度（包括终止符）。</li>
</ul>
<h3 id="函数原型："><a href="#函数原型：" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cutils/properties.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> value[<span class="hljs-number">256</span>];<br>    <span class="hljs-comment">// 获取系统属性 &quot;ro.product.model&quot;（设备型号）</span><br>    <span class="hljs-keyword">if</span> (system_property_get(<span class="hljs-string">&quot;ro.product.model&quot;</span>, value)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Device model: %s\n&quot;</span>, value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Failed to get system property.\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>这段代码使用 <code>system_property_get</code> 获取设备的型号（<code>ro.product.model</code>），并打印出该值</p>
<h2 id="system-property-fin"><a href="#system-property-fin" class="headerlink" title="system_property_fin"></a>system_property_fin</h2><p><code>system_property_find</code> 用于查找一个系统属性是否存在。与 <code>system_property_get</code> 不同的是，<code>system_property_find</code> 不会直接获取值，它只是检查属性是否存在。</p>
<h3 id="函数原型：-1"><a href="#函数原型：-1" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">const</span> PropInfo* <span class="hljs-title function_">system_property_find</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>;<br></code></pre></td></tr></table></figure>

<ul>
<li>**<code>name</code>**：要查找的系统属性的名称。</li>
<li><strong>返回值</strong>：返回 <code>PropInfo</code> 结构体指针，如果属性存在，返回指向该属性的指针；如果不存在，返回 <code>NULL</code>。</li>
</ul>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cutils/properties.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">const</span> PropInfo *prop_info;<br><br>    <span class="hljs-comment">// 查找系统属性 &quot;ro.build.version.release&quot;（Android版本）</span><br>    prop_info = system_property_find(<span class="hljs-string">&quot;ro.build.version.release&quot;</span>);<br>    <span class="hljs-keyword">if</span> (prop_info) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Property exists!\n&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Property not found.\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>解释</strong>：这段代码通过 <code>system_property_find</code> 检查是否存在系统属性 <code>ro.build.version.release</code>，该属性存储了设备的 Android 版本。</li>
</ul>
<h2 id="system-property-rea"><a href="#system-property-rea" class="headerlink" title="system_property_rea"></a>system_property_rea</h2><p><code>system_property_read</code> 是另一个获取系统属性的函数，它与 <code>system_property_get</code> 类似，但是在返回时，它提供了更详细的错误信息。它读取属性的值，并且返回成功与否。</p>
<h3 id="函数原型：-2"><a href="#函数原型：-2" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">int</span> <span class="hljs-title function_">system_property_read</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">char</span> *value)</span><br></code></pre></td></tr></table></figure>

<ul>
<li>**<code>name</code>**：要读取的系统属性名称。</li>
<li>**<code>value</code>**：属性的值将存储在此字符数组中。</li>
<li><strong>返回值</strong>：返回值为 0 表示失败，非 0 表示成功。</li>
</ul>
<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cutils/properties.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> value[<span class="hljs-number">256</span>];<br><br>    <span class="hljs-comment">// 读取系统属性 &quot;ro.product.manufacturer&quot;（厂商）</span><br>    <span class="hljs-keyword">if</span> (system_property_read(<span class="hljs-string">&quot;ro.product.manufacturer&quot;</span>, value)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Manufacturer: %s\n&quot;</span>, value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Failed to read system property.\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>解释</strong>：这段代码读取 <code>ro.product.manufacturer</code> 属性，这个属性表示设备的制造商，并打印出它的值。</li>
</ul>
<p>这三个函数都是与 Android 系统属性相关的 API，用于获取、查找和读取系统属性值。</p>
<ul>
<li>**<code>system_property_get</code>**：用来获取指定系统属性的值。</li>
<li>**<code>system_property_find</code>**：用来查找指定的系统属性是否存在。</li>
<li>**<code>system_property_read</code>**：读取指定系统属性的值，返回成功或失败。</li>
</ul>
<p>然而除了刚刚上面的传统的直接读取系统属性的方法（存在弊端，高版本Android限制普通App访问敏感属性），我们还有</p>
<ul>
<li>**读取<code>/proc/sys/kernel/random/boot_id</code>**：通过文件I&#x2F;O获取设备标识。</li>
<li><strong>反射<code>mValues</code>映射</strong>：反射修改SystemProperties的私有变量，需突破反射限制。</li>
</ul>
<p>但是这样的方法也存在弊端，比如需声明权限（如READ_PHONE_STATE ），易被Xposed&#x2F;Frida等框架Hook拦截，改机软件可伪造返回值等</p>
<p>而本文则通过netlinker（内核级别）来演示如何通过与内核交互并通过套接字发送请求和接收响应。相比于Android应用层（如Java层或Native层）获取信息，Netlink通信的过程是更加底层和透明的，绕过了Android的框架层。<strong>内核数据访问不依赖于用户权限</strong>：Netlink允许直接从内核获取硬件信息（如MAC地址），而无需通过Android权限系统的层级保护。也就是说，改机软件无法像在应用层通过修改Android权限或模拟权限来伪造或篡改信息，因为Netlink通信不依赖于这些权限。</p>
<p>Netlink是一种Linux内核与用户空间通信的机制，允许用户空间程序与内核交互。</p>
<p>通过Netlink方式与Linux内核通信，可以直接查询网卡硬件信息，包括设备的<strong>MAC地址</strong>。</p>
<p>改机软件通常是通过在<strong>用户空间</strong>（应用程序层）进行数据篡改的，或者通过动态库修改来影响系统调用（如<code>recv</code>、<code>recvfrom</code>等）。这些修改会依赖于在应用层或库层的访问权限进行实现</p>
<p>即使APP未被授予网络权限或其他系统权限，也可直接通过Netlink通信访问内核网络接口信息。这种方式访问的是设备底层真实信息，绕过了Android框架层面可能做的伪装或干扰，几乎无法被Mock或模拟伪造，因此非常适合大厂APP做设备唯一标识（设备指纹）的用途。</p>
<p><strong>设备指纹的唯一性与不可伪造性</strong>：</p>
<ul>
<li>获取MAC地址作为设备唯一标识的一部分，具有很强的不可伪造性。即使设备发生了修改（如刷机、虚拟化、模拟等），通常很难改变网卡硬件的MAC地址。而通过Netlink直接获取的MAC地址来自硬件层，改机软件通常难以模拟真实硬件的MAC地址。</li>
<li>改机软件的目标是通过修改Android系统或应用层的标识（如Android ID、IMEI等）来伪装设备。但是，<strong>Netlink方式直接从内核获取MAC地址</strong>，这种方法直接触及硬件信息，几乎不可能通过普通的软件手段进行修改或伪造。</li>
</ul>
<p>这里复习一下进程间通信方式：</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1tv411p7WX/?spm_id_from=333.337.search-card.all.click&vd_source=d7f903c8e55e49011126ea9ac27a3d31">https://www.bilibili.com/video/BV1tv411p7WX/?spm_id_from=333.337.search-card.all.click&amp;vd_source=d7f903c8e55e49011126ea9ac27a3d31</a></p>
<p><a target="_blank" rel="noopener" href="https://www.notion.so/202a1163aa0b8041b0e8da440f51d2cc?pvs=21">进程间通信方式</a> </p>
<p>用户空间进程间通信通常有更常用、更简单的机制 (如管道、消息队列、共享内存、Unix Domain Socket、TCP&#x2F;UDP Socket 等)。因此，<strong>Netlink 一般不被用于普通的进程间通信</strong>。只有当需要利用 Netlink 特有的 <strong>广播 (Broadcast)</strong> 或 <strong>组播 (Multicast)</strong> 特性时 (一个进程发送消息，多个监听该 Netlink 协议&#x2F;组的进程都能收到)，才会考虑在用户态进程间使用 Netlink。</p>
<p><strong>Netlink机制是一种特殊的socket：</strong></p>
<ul>
<li><strong>解释：</strong> Netlink 的实现基础是 <strong>BSD Socket API</strong>。这意味着用户态程序使用 Netlink 的方式与使用 TCP 或 UDP Socket 非常相似：**<code>socket()</code>**, <strong><code>bind()</code></strong>, <strong><code>sendmsg()</code></strong>, <strong><code>recvmsg()</code></strong>, <strong><code>close()</code></strong> 等系统调用。</li>
<li><strong>关键区别：</strong> 它是“特殊”的，因为它使用的不是 <strong><code>AF_INET</code></strong> 或 <strong><code>AF_UNIX</code></strong> 这样的地址族，而是专门为内核通信设计的 <strong><code>AF_NETLINK</code></strong> 地址族。</li>
</ul>
<p>因为 Linux 把 Netlink 当作一种特殊的「协议族」（Protocol Family）来实现，就像 AF_INET（IPv4）、AF_INET6（IPv6）一样，对应的就是 AF_NETLINK；而在内核角度，又把它映射到标准的套接字层（Socket Layer）。</p>
<p>因此，从用户态的视角看，Netlink 就和 TCP&#x2F;UDP 之类的「套接字协议」没什么区别：</p>
<ol>
<li><p><strong><code>socket(AF_NETLINK, SOCK_DGRAM, protocol)</code></strong><br> ↳ 创建一个 Netlink 套接字，<code>protocol</code> 指定子协议（路由表、链接状态、SELinux 通知等）。</p>
</li>
<li><p><strong><code>bind()</code></strong><br> ↳ 绑定到某个 Netlink 组（group）或进程 ID，以接收内核发来的消息。</p>
</li>
<li><p><strong><code>sendmsg()</code> &#x2F; <code>recvmsg()</code></strong><br> ↳ 发送／接收 Netlink 消息。你把自定义的 <code>nlmsghdr</code> + payload 塞进去，内核那头就能正确解析，反过来内核发出的消息也会执行相同的封包／解包流程。</p>
</li>
<li><p><strong><code>close()</code></strong><br> ↳ 关闭套接字，内核释放相关资源。</p>
</li>
</ol>
<p><strong>异步通信机制：</strong></p>
<ul>
<li><strong>核心特性：</strong> 这是 Netlink 区别于 <strong><code>ioctl</code></strong> 和 <strong><code>procfs/sysfs</code></strong> 读写的关键点。</li>
<li><strong>运作方式：</strong> 当消息通过 Netlink Socket 发送时，它首先被放入接收端的 <strong>Socket 接收缓冲区</strong> 中排队。接收端 (无论是内核还是用户态进程) <strong>不会立即被阻塞或中断</strong> 来处理这条消息。接收端会在它<strong>下一次主动去检查</strong> (例如，调用 <strong><code>recvmsg()</code></strong> 系统调用) 其 Socket 接收缓冲区时，才会获取并处理这些消息。</li>
<li><strong>优势：</strong><ul>
<li><strong>发送方非阻塞：</strong> 发送方发送消息后通常可以继续执行，无需等待接收方处理完毕 (除非缓冲区满导致阻塞)。</li>
<li><strong>接收方控制节奏：</strong> 接收方可以以自己的节奏处理消息，不会被突如其来的消息强制打断当前工作。</li>
<li><strong>解耦：</strong> 生产者和消费者在时间上解耦。</li>
</ul>
</li>
<li><strong>对比同步机制 (如 ioctl &#x2F; 系统调用)：</strong><ul>
<li><strong>同步：</strong> 调用 <strong><code>ioctl()</code></strong> 或进行 <strong><code>procfs/sysfs</code></strong> 文件读写 (<strong><code>read()/write()</code></strong>) 时，**用户进程会一直阻塞 (等待)**，直到内核完成该操作并将结果返回。内核处理是立即发生的、是调用的一部分。用户进程必须等待结果。</li>
</ul>
</li>
</ul>
<ol>
<li><strong>用户空间和内核空间的通信方式有三种：proc, ioctl, Netlink：</strong><ul>
<li><strong>解释：</strong> 这句话列举了 Linux 中用户态与内核态进行数据交换的三种<strong>主要传统机制</strong> (现代还有 sysfs, configfs, debugfs, perf_event, bpf_map 等更多方式)：<ul>
<li><strong>proc (&#x2F;proc 文件系统)：</strong> 一个虚拟文件系统，内核通过文件的形式暴露信息 (如 <strong><code>/proc/cpuinfo</code></strong>, <strong><code>/proc/meminfo</code></strong>, <strong><code>/proc/net/route</code></strong>)。用户进程通过标准文件 I&#x2F;O (<strong><code>open(), read(), write(), close()</code></strong>) 访问。主要用于<strong>内核向用户空间输出信息</strong>，部分文件可写用于配置。本质是同步的 (<strong><code>read/write</code></strong> 调用会阻塞)。</li>
<li><strong>ioctl：</strong> 一个系统调用 (<strong><code>int ioctl(int fd, unsigned long request, ...);</code></strong>)，用于对<strong>已打开的文件描述符</strong>所代表的设备或对象进行<strong>特定于该设备的控制操作</strong>。这是驱动程序与用户空间交互的常用方式 (如设置串口波特率、控制网卡模式)。它是<strong>同步</strong>的、<strong>命令-响应</strong>模式的。</li>
<li><strong>Netlink：</strong> 如前所述，基于 Socket 的<strong>异步</strong>、<strong>双向</strong>通信机制。</li>
</ul>
</li>
<li><strong>注意：</strong> 虽然 <strong><code>proc</code></strong> 和 <strong><code>ioctl</code></strong> 在主要用途上常常表现为单向 (<strong><code>proc</code></strong> 侧重读，**<code>ioctl</code>** 侧重写&#x2F;控制)，但技术上：<ul>
<li>**<code>proc</code>**： 很多文件是只读的 (内核-&gt;用户)，但部分文件可写 (用户-&gt;内核)。</li>
<li><strong><code>ioctl</code><strong>： 主要用途是用户向设备发送命令 (</strong><code>request</code></strong>) 和可能的参数 (-&gt;内核)，同时也能通过其参数或返回值从内核获取信息 (&lt;-内核)。所以 <strong><code>ioctl</code></strong> 本身也是双向的，但它是同步的、命令驱动的。Netlink 的“双工”更强调的是基于消息流的、非阻塞的双向通信能力。</li>
</ul>
</li>
</ul>
</li>
<li><strong>Netlink可以实现双工通信：</strong><ul>
<li><strong>解释：</strong> “双工通信”意味着数据可以在<strong>两个方向上独立地、同时地</strong>流动。</li>
<li><strong>在 Netlink 中的体现：</strong> 建立一个 Netlink Socket 连接后：<ul>
<li>用户空间进程可以<strong>主动发送消息</strong>给内核模块。</li>
<li>内核模块也可以<strong>主动发送消息</strong>给用户空间进程 (例如，异步通知事件的发生，如网卡状态变化、路由表更新、热插拔事件)。</li>
<li>这种消息的发送和接收是独立的，不需要像 <strong><code>ioctl</code></strong> 那样严格遵循“请求-响应”模式。内核可以主动推送消息给监听者。这是 Netlink 相对于 <strong><code>proc</code></strong> (主要读) 和 <strong><code>ioctl</code></strong> (主要是命令&#x2F;请求) 在通信模式上的重大优势。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>异步通信机制：</strong></p>
<ul>
<li><strong>核心特性：</strong> 这是 Netlink 区别于 <strong><code>ioctl</code></strong> 和 <strong><code>procfs/sysfs</code></strong> 读写的关键点。</li>
<li><strong>运作方式：</strong> 当消息通过 Netlink Socket 发送时，它首先被放入接收端的 <strong>Socket 接收缓冲区</strong> 中排队。接收端 (无论是内核还是用户态进程) <strong>不会立即被阻塞或中断</strong> 来处理这条消息。接收端会在它<strong>下一次主动去检查</strong> (例如，调用 <strong><code>recvmsg()</code></strong> 系统调用) 其 Socket 接收缓冲区时，才会获取并处理这些消息。</li>
<li><strong>优势：</strong><ul>
<li><strong>发送方非阻塞：</strong> 发送方发送消息后通常可以继续执行，无需等待接收方处理完毕 (除非缓冲区满导致阻塞)。</li>
<li><strong>接收方控制节奏：</strong> 接收方可以以自己的节奏处理消息，不会被突如其来的消息强制打断当前工作。</li>
<li><strong>解耦：</strong> 生产者和消费者在时间上解耦。</li>
</ul>
</li>
</ul>
<ol>
<li><strong>Netlink协议基于BSD socket和AF_NETLINK地址簇(address family)：</strong><ul>
<li><strong>BSD Socket：</strong> 指符合 Berkeley Software Distribution (BSD) 操作系统定义的 Socket 编程接口标准。Linux 实现了这套广泛使用的标准 API。Netlink 复用这套成熟的 API，降低了用户态开发者的学习成本。</li>
<li><strong>AF_NETLINK地址簇：</strong> 这是定义 Netlink 类型的关键。创建 Netlink Socket 时，必须指定 <strong><code>domain/address family</code></strong> 参数为 <strong><code>AF_NETLINK</code></strong> (或等价常量 <strong><code>PF_NETLINK</code></strong>)。这告诉内核：“我要创建的是一个用于 Netlink IPC 的 Socket，而不是用于网络 (<strong><code>AF_INET/AF_INET6</code></strong>) 或本地 (<strong><code>AF_UNIX</code></strong>) 通信的 Socket”。</li>
</ul>
</li>
<li><strong>使用32位的端口号寻址(以前称为PID)：</strong><ul>
<li><strong>寻址机制：</strong> 为了标识通信的端点，Netlink 使用一个 32 位的无符号整数作为**端口号 (Port ID)**。</li>
<li><strong>历史名称 (PID)：</strong> 在早期实现中，内核通常将发送消息的用户态进程的进程 ID (PID) 自动用作其 Netlink 消息的源端口号。因此，这个标识符常被称为 PID。<strong>现在更准确的术语是 Port ID 或 nl_pid。</strong></li>
<li><strong>当前用法：</strong><ul>
<li><strong>用户态：</strong> 用户态进程在 <strong><code>bind()</code></strong> 其 Netlink Socket 时，需要指定一个 <strong><code>nl_pid</code></strong> (端口号)。这通常是该进程自己选择的唯一标识符 (常用进程 PID，但不是必须的)。它标识了这个用户态 Socket 端点。</li>
<li><strong>内核态：</strong> 内核端的 Netlink 端点通常固定使用 Port ID **<code>0</code>**。</li>
</ul>
</li>
<li><strong>作用：</strong> Port ID 用于确保消息被路由到正确的目的地 Socket。内核在发送消息给用户态时，会指定目标 Port ID。用户态在发送消息给内核时，内核知道来源 Port ID，以便回复。</li>
</ul>
</li>
<li><strong>每个Netlink协议(或称作总线，man手册中则称之为netlink family)：</strong><ul>
<li><strong>概念：</strong> <strong><code>AF_NETLINK</code></strong> 是一个大的地址族，其下细分为多个具体的 <strong>Netlink 协议族</strong> 或 <strong>Netlink 总线</strong>。你可以把它们想象成不同的“频道”或“线路”。</li>
<li><strong>标识：</strong> 创建 Socket (<strong><code>socket()</code></strong>) 时，除了指定 **<code>AF_NETLINK</code>**，还需要指定具体的协议族 <strong><code>protocol</code></strong> (如 <strong><code>NETLINK_ROUTE</code></strong>, <strong><code>NETLINK_KOBJECT_UEVENT</code></strong>)。</li>
<li><strong>作用：</strong> 不同的协议族用于<strong>隔离不同的通信主题和目的</strong>。内核中不同的子系统会注册处理特定 Netlink 协议族上的消息。这避免了所有内核通信都挤在一个通道上，提高了效率和安全性。</li>
</ul>
</li>
<li><strong>通常与一个或者一组内核服务&#x2F;组件相关联：</strong><ul>
<li><strong>解释：</strong> 每个预定义的 Netlink 协议族 (<strong><code>NETLINK_XXX</code></strong>) 都被设计用来服务于特定的内核功能模块或子系统。</li>
<li><strong>例子：</strong><ul>
<li><strong><code>NETLINK_ROUTE</code><strong>： <strong>关联内核网络子系统。</strong> 用于获取和设置 <strong>路由表、网络接口 (链路) 信息 (IP 地址、状态、MTU 等)、邻居表 (ARP&#x2F;NDISC)、流量控制 (QoS)、网络命名空间</strong> 等。</strong><code>iproute2</code></strong> 工具包 (<strong><code>ip</code></strong>, <strong><code>ss</code></strong>, <strong><code>tc</code></strong> 命令) 主要使用此协议族与内核通信。</li>
<li>**<code>NETLINK_KOBJECT_UEVENT</code>**： <strong>关联内核设备模型和热插拔机制。</strong> 内核通过此协议族向用户空间的 <strong>udev</strong> 守护进程发送 <strong>设备事件通知</strong> (如 USB 设备插入&#x2F;拔出、磁盘添加&#x2F;移除、设备状态变化)。udev 监听此总线并根据事件动态管理 <strong><code>/dev</code></strong> 下的设备节点和规则。</li>
</ul>
</li>
<li><strong>其他常见协议族举例：</strong><ul>
<li><strong><code>NETLINK_GENERIC</code><strong>： 一个更通用的框架，允许内核模块动态定义自己的子协议 (属性)，无需申请新的顶层协议号。非常灵活，许多较新的内核功能通过它暴露 (</strong><code>genetlink</code></strong>)。</li>
<li><strong><code>NETLINK_SOCK_DIAG</code><strong>： 用于查询套接字诊断信息 (</strong><code>ss</code></strong> 命令使用)。</li>
<li>**<code>NETLINK_NETFILTER</code>**： 用于与 Netfilter 子系统 (iptables&#x2F;nftables 底层) 通信，配置防火墙规则、获取连接跟踪信息等。</li>
<li>**<code>NETLINK_AUDIT</code>**： 用于内核审计子系统向用户空间 <strong><code>auditd</code></strong> 守护进程发送审计记录。</li>
<li>**<code>NETLINK_SELINUX</code>**： 用于 SELinux 安全模块的通信。</li>
<li>**<code>NETLINK_CRYPTO</code>**： 用于配置内核加密算法和接口。</li>
<li>**<code>NETLINK_SCSITRANSPORT</code>**： 用于 SCSI 传输层管理。</li>
<li>**<code>NETLINK_RDMA</code>**： 用于 RDMA (远程直接内存访问) 子系统。</li>
<li>**<code>NETLINK_FIB_LOOKUP</code>**： 用于进行 FIB (转发信息库) 查找 (较旧&#x2F;特定场景)。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>总结关键点：</strong></p>
<ul>
<li><strong>本质：</strong> 基于 Socket (<strong><code>AF_NETLINK</code></strong>) 的异步 IPC。</li>
<li><strong>主场景：</strong> <strong>用户态 &lt;-&gt; 内核态</strong> 双向通信。</li>
<li><strong>次场景：</strong> 用户态进程间通信 (需利用<strong>广播&#x2F;组播</strong>特性时)。</li>
<li><strong>核心优势：</strong><ul>
<li><strong>异步：</strong> 非阻塞，消息缓冲。</li>
<li><strong>双向：</strong> 内核可主动推送消息。</li>
<li><strong>广播&#x2F;组播：</strong> 支持一对多通信。</li>
<li><strong>结构化消息：</strong> 使用基于属性的消息格式 (如 <strong><code>nlmsghdr</code></strong> + 属性 <strong><code>nlattr</code></strong>)，比 <strong><code>ioctl</code></strong> 魔数和 <strong><code>procfs</code></strong> 文本解析更健壮灵活。</li>
<li><strong>标准化：</strong> 复用 Socket API。</li>
</ul>
</li>
<li><strong>寻址：</strong> 32 位 Port ID (<strong><code>nl_pid</code></strong>)。</li>
<li><strong>组织：</strong> 划分为多个协议族 (<strong><code>NETLINK_XXX</code></strong>)，每个服务于特定的内核子系统 (<strong><code>NETLINK_ROUTE</code></strong> for 网络, <strong><code>NETLINK_KOBJECT_UEVENT</code></strong> for 设备事件 等)。</li>
</ul>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>源码参考：<a target="_blank" rel="noopener" href="https://cs.android.com/android/platform/superproject/main/+/main:bionic/libc/bionic/ifaddrs.cpp?hl=zh-cn">https://cs.android.com/android/platform/superproject/main/+/main:bionic/libc/bionic/ifaddrs.cpp?hl=zh-cn</a></p>
<p>（之前作者给的连接的帖子无了）</p>
<p>302行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">getifaddrs</span><span class="hljs-params">(ifaddrs** out)</span> &#123;<br>  <span class="hljs-comment">// We construct the result directly into `out`, so terminate the list.</span><br>  *out = nullptr;<br><br>  <span class="hljs-comment">// Open the netlink socket and ask for all the links and addresses.</span><br>  NetlinkConnection nc;<br>  <span class="hljs-comment">// SELinux policy only allows RTM_GETLINK messages to be sent by system apps.</span><br>  <span class="hljs-type">bool</span> getlink_success = <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">if</span> (getuid() &lt; FIRST_APPLICATION_UID) &#123;<br>    getlink_success = nc.SendRequest(RTM_GETLINK) &amp;&amp; nc.ReadResponses(__getifaddrs_callback, out);<br>  &#125;<br>  <span class="hljs-type">bool</span> getaddr_success =<br>    nc.SendRequest(RTM_GETADDR) &amp;&amp; nc.ReadResponses(__getifaddrs_callback, out);<br><br>  <span class="hljs-keyword">if</span> (!getaddr_success) &#123;<br>    freeifaddrs(*out);<br>    <span class="hljs-comment">// Ensure that callers crash if they forget to check for success.</span><br>    *out = nullptr;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (!getlink_success) &#123;<br>    <span class="hljs-comment">// If we weren&#x27;t able to depend on GETLINK messages, it&#x27;s possible some</span><br>    <span class="hljs-comment">// interfaces never got their name set. Resolve them using if_indextoname or remove them.</span><br>    resolve_or_remove_nameless_interfaces(out);<br>    <span class="hljs-comment">// Similarly, without GETLINK messages, interfaces will not have their flags set.</span><br>    <span class="hljs-comment">// Resolve them using the SIOCGIFFLAGS ioctl call.</span><br>    get_interface_flags_via_ioctl(out);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个 <code>getifaddrs</code> 实现流程：</p>
<ol>
<li>初始化输出指针。</li>
<li>使用 Netlink 请求接口信息（<code>RTM_GETLINK</code> 和 <code>RTM_GETADDR</code>）。</li>
<li>对于权限不足的情况，使用替代手段补全信息。</li>
<li>构建 <code>ifaddrs</code> 链表并返回。</li>
</ol>
<p>它兼顾了系统级服务和普通应用之间的权限差异，具有较强的容错和兼容性。</p>
<ul>
<li><p><code>RTM_GETLINK</code> 是 <strong>Netlink 路由协议（NETLINK_ROUTE）</strong> 中的一个消息类型</p>
</li>
<li><p>它用于请求内核返回系统中所有<strong>网络接口（network links）</strong>的信息</p>
</li>
</ul>
<h2 id="第-1-行"><a href="#第-1-行" class="headerlink" title="第 1 行"></a>第 1 行</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-type">bool</span> getlink_success = <span class="hljs-literal">false</span>;<br><br></code></pre></td></tr></table></figure>

<ul>
<li><p>声明并初始化一个布尔变量 <code>getlink_success</code>，表示是否成功通过 netlink 获取到网络接口的基本信息。</p>
</li>
<li><p>初始设为 <code>false</code>，后面会尝试赋值为真实状态。</p>
<hr>
<h2 id="🔍-第-2-行：权限判断"><a href="#🔍-第-2-行：权限判断" class="headerlink" title="🔍 第 2 行：权限判断"></a>🔍 第 2 行：权限判断</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">getuid</span>() &lt; FIRST_APPLICATION_UID)<br><br></code></pre></td></tr></table></figure>
</li>
<li><p><code>getuid()</code> 返回当前进程的 <strong>实际用户 ID</strong>。</p>
</li>
<li><p><code>FIRST_APPLICATION_UID</code> 是一个系统常量，通常在 Android 中定义为 <strong>应用用户 UID 的起始值</strong>，一般是 <strong>10000</strong>。</p>
<ul>
<li>系统进程 UID 通常小于 10000（如 system: 1000，root: 0）。</li>
</ul>
</li>
<li><p>因此，<code>getuid() &lt; FIRST_APPLICATION_UID</code> 用于判断：<strong>当前进程是否是系统级别的进程（非第三方 App）</strong>。</p>
<h3 id="✅-背景解释："><a href="#✅-背景解释：" class="headerlink" title="✅ 背景解释："></a>✅ 背景解释：</h3></li>
<li><p><strong>为什么要判断 UID？</strong></p>
<ul>
<li>Android 的 SELinux 策略限制普通应用不能发送 <code>RTM_GETLINK</code> 类型的 netlink 请求。</li>
<li>如果当前进程是普通 App，发送这个请求会被系统拒绝或返回错误。</li>
<li>所以为了安全，只有系统 UID 才去尝试发这个请求。</li>
</ul>
<hr>
<h2 id="🔍-第-3-行：发送请求并读取相应"><a href="#🔍-第-3-行：发送请求并读取相应" class="headerlink" title="🔍 第 3 行：发送请求并读取相应"></a>🔍 第 3 行：发送请求并读取相应</h2><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><br><span class="hljs-attr">getlink_success</span> = nc.SendRequest(RTM_GETLINK) &amp;&amp; nc.ReadResponses(__getifaddrs_callback, out)<span class="hljs-comment">;</span><br><br></code></pre></td></tr></table></figure>

<p>这行代码包含两部分：</p>
</li>
</ul>
<ol>
<li><code>nc.SendRequest(RTM_GETLINK)</code><ul>
<li>使用 <code>NetlinkConnection</code> 实例 <code>nc</code> 向内核发送一个 <code>RTM_GETLINK</code> 请求。</li>
<li>该请求用于获取 <strong>所有网络接口的基本信息</strong>，例如接口名称、MTU、MAC 地址、设备状态（up&#x2F;down）等。</li>
</ul>
</li>
<li><code>nc.ReadResponses(__getifaddrs_callback, out)</code><ul>
<li>从 netlink socket 中读取内核返回的响应消息。</li>
<li>读取到的每个消息都交给回调函数 <code>__getifaddrs_callback</code> 处理。</li>
<li>回调函数负责解析消息，并将解析出的信息写入到 <code>out</code> 指向的 <code>ifaddrs</code> 链表中。</li>
</ul>
</li>
<li>两个操作用 <code>&amp;&amp;</code> 连接，表示<strong>两个操作都成功才算成功</strong>，否则结果为 <code>false</code>。</li>
</ol>
<table>
<thead>
<tr>
<th>部分</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>getuid()</code></td>
<td>获取当前用户 ID</td>
</tr>
<tr>
<td><code>&lt; FIRST_APPLICATION_UID</code></td>
<td>判断是否为系统进程</td>
</tr>
<tr>
<td><code>RTM_GETLINK</code></td>
<td>请求网络接口基础信息（如接口名、状态）</td>
</tr>
<tr>
<td><code>NetlinkConnection::SendRequest()</code></td>
<td>向内核发送 Netlink 请求</td>
</tr>
<tr>
<td><code>NetlinkConnection::ReadResponses()</code></td>
<td>读取并处理内核返回</td>
</tr>
<tr>
<td><code>__getifaddrs_callback</code></td>
<td>回调函数，构建 <code>ifaddrs</code> 链表</td>
</tr>
<tr>
<td><code>getlink_success</code></td>
<td>表示是否成功获取接口基础信息</td>
</tr>
</tbody></table>
<p>bionic&#x2F;libc&#x2F;bionic&#x2F;bionic_netlink.cpp：</p>
<p>第52行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">NetlinkConnection::SendRequest</span><span class="hljs-params">(<span class="hljs-type">int</span> type)</span> &#123;<br>  <span class="hljs-comment">// Rather than force all callers to check for the unlikely event of being</span><br>  <span class="hljs-comment">// unable to allocate 8KiB, check here.</span><br>  <span class="hljs-keyword">if</span> (data_ == nullptr) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// Did we open a netlink socket yet?</span><br>  <span class="hljs-keyword">if</span> (fd_.get() == <span class="hljs-number">-1</span>) &#123;<br>    fd_.reset(socket(PF_NETLINK, SOCK_RAW | SOCK_CLOEXEC, NETLINK_ROUTE));<br>    <span class="hljs-keyword">if</span> (fd_.get() == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Construct and send the message.</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NetlinkMessage</span> &#123;</span><br>    nlmsghdr hdr;<br>    rtgenmsg msg;<br>  &#125; request;<br>  <span class="hljs-built_in">memset</span>(&amp;request, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(request));<br>  request.hdr.nlmsg_flags = NLM_F_DUMP | NLM_F_REQUEST;<br>  request.hdr.nlmsg_type = type;<br>  request.hdr.nlmsg_len = <span class="hljs-keyword">sizeof</span>(request);<br>  request.msg.rtgen_family = AF_UNSPEC; <span class="hljs-comment">// All families.</span><br>  <span class="hljs-keyword">return</span> (TEMP_FAILURE_RETRY(send(fd_.get(), &amp;request, <span class="hljs-keyword">sizeof</span>(request), <span class="hljs-number">0</span>)) == <span class="hljs-keyword">sizeof</span>(request));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里要构造并发送一个最小的 Netlink 报文请求给内核：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">NetlinkMessage</span> &#123;<br>  nlmsghdr hdr;<br>  rtgenmsg msg;<br>&#125; request;<br><br></code></pre></td></tr></table></figure>

<ul>
<li>定义了一个局部结构体 <code>NetlinkMessage</code>，包含两部分：<ol>
<li><code>nlmsghdr hdr;</code> —— Netlink 报文头，用来描述消息的类型、长度和标志；</li>
<li><code>rtgenmsg msg;</code> —— 路由生成消息体，最小的负载，用于指定要查询的地址族。</li>
</ol>
</li>
<li><code>request</code> 是该结构的一个实例，后续会填充字段并发送。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-built_in">memset</span>(&amp;request, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(request));<br><br></code></pre></td></tr></table></figure>

<ul>
<li>将 <code>request</code> 整块内存清零，保证所有字段初始为 0，避免垃圾值。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>request.hdr.nlmsg_flags = NLM_F_DUMP | NLM_F_REQUEST;<br><br></code></pre></td></tr></table></figure>

<ul>
<li><code>nlmsg_flags</code> 是 Netlink 报文头的标志位：<ul>
<li><code>NLM_F_REQUEST</code> 表示这是一个请求报文。</li>
<li><code>NLM_F_DUMP</code> 通常配合请求使用，告诉内核“请把对应表（如路由表、接口表）全量导出给我”。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>request.hdr.nlmsg_type = type;<br><br></code></pre></td></tr></table></figure>

<ul>
<li><code>nlmsg_type</code> 指定要请求的动作／资源类型，<code>type</code> 由调用者传入，如：<ul>
<li><code>RTM_GETLINK</code> 获取网络接口列表</li>
<li><code>RTM_GETADDR</code> 获取接口地址</li>
<li><code>RTM_GETROUTE</code> 获取路由表 等。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>request.hdr.nlmsg_len = <span class="hljs-built_in">sizeof</span>(request);<br><br></code></pre></td></tr></table></figure>

<ul>
<li><code>nlmsg_len</code> 是整个 Netlink 消息（包括 <code>hdr</code> + <code>msg</code>）的字节总长度，用于内核解析时知道读多少。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">// All families</span><br>request.msg.rtgen_family = AF_UNSPEC;<br><br></code></pre></td></tr></table></figure>

<ul>
<li><code>rtgenmsg</code> 里的 <code>rtgen_family</code> 字段指定查询哪个地址族：<ul>
<li><code>AF_UNSPEC</code> 表示不过滤，IPv4、IPv6、甚至本地（AF_PACKET）都一并返回。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">//使用socket数据发送</span><br><span class="hljs-keyword">return</span> (<span class="hljs-built_in">TEMP_FAILURE_RETRY</span>(<br>    <span class="hljs-built_in">send</span>(fd_, &amp;request, <span class="hljs-built_in">sizeof</span>(request), <span class="hljs-number">0</span>)<br>) == <span class="hljs-built_in">sizeof</span>(request));<br><br></code></pre></td></tr></table></figure>

<ul>
<li><code>send(fd_, &amp;request, sizeof(request), 0)</code>：将构造好的 <code>request</code> 原封不动地写入 Netlink socket。</li>
<li><code>TEMP_FAILURE_RETRY(...)</code> 宏会在调用因信号中断（EINTR）时自动重试。</li>
<li>最后比较实际发送的字节数是否等于 <code>sizeof(request)</code>：<ul>
<li>相等则发送完整成功，返回 <code>true</code>；</li>
<li>否则（失败或只发出部分字节）返回 <code>false</code>。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>整体流程</strong>：</p>
<ol>
<li>清零构造一个最简 Netlink 请求报文。</li>
<li>标记为「请求 + 全量导出」，指定消息类型和长度。</li>
<li>将地址族设为 <code>AF_UNSPEC</code>（查询所有）。</li>
<li>通过 <code>send()</code> 发给内核，返回是否成功。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">NetlinkConnection::ReadResponses</span><span class="hljs-params">(<span class="hljs-type">void</span> callback(<span class="hljs-type">void</span>*, nlmsghdr*), <span class="hljs-type">void</span>* context)</span> &#123;<br>  <span class="hljs-comment">// Read through all the responses, handing interesting ones to the callback.</span><br>  <span class="hljs-type">ssize_t</span> bytes_read;<br>  <span class="hljs-keyword">while</span> ((bytes_read = TEMP_FAILURE_RETRY(recv(fd_.get(), data_, size_, <span class="hljs-number">0</span>))) &gt; <span class="hljs-number">0</span>) &#123;<br>    nlmsghdr* hdr = reinterpret_cast&lt;nlmsghdr*&gt;(data_);<br>    <span class="hljs-keyword">for</span> (; NLMSG_OK(hdr, static_cast&lt;<span class="hljs-type">size_t</span>&gt;(bytes_read)); hdr = NLMSG_NEXT(hdr, bytes_read)) &#123;<br>      <span class="hljs-keyword">if</span> (hdr-&gt;nlmsg_type == NLMSG_DONE) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      <span class="hljs-keyword">if</span> (hdr-&gt;nlmsg_type == NLMSG_ERROR) &#123;<br>        nlmsgerr* err = reinterpret_cast&lt;nlmsgerr*&gt;(NLMSG_DATA(hdr));<br>        errno = (hdr-&gt;nlmsg_len &gt;= NLMSG_LENGTH(<span class="hljs-keyword">sizeof</span>(nlmsgerr))) ? -err-&gt;error : EIO;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>      callback(context, hdr);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// We only get here if recv fails before we see a NLMSG_DONE.</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>注释版</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">NetlinkConnection::ReadResponses</span><span class="hljs-params">(<span class="hljs-type">void</span> callback(<span class="hljs-type">void</span>*, nlmsghdr*), <span class="hljs-type">void</span>* context)</span> &#123;<br>    <span class="hljs-comment">// 循环接收内核通过 Netlink socket 返回的数据</span><br>    <span class="hljs-type">ssize_t</span> bytes_read;<br>    <span class="hljs-keyword">while</span> ((bytes_read = TEMP_FAILURE_RETRY(<br>                recv(fd_.get(),      <span class="hljs-comment">// 从已打开的 netlink socket 读取</span><br>                     data_,          <span class="hljs-comment">// 存放到构造时分配的缓冲区</span><br>                     size_,          <span class="hljs-comment">// 缓冲区大小，一般 8KiB</span><br>                     <span class="hljs-number">0</span>               <span class="hljs-comment">// 默认标志</span><br>                )))<br>           &gt; <span class="hljs-number">0</span>) &#123;               <span class="hljs-comment">// 只要读取到字节就继续处理</span><br><br>        <span class="hljs-comment">// 将缓冲区数据解释为第一个 nlmsghdr 报文头</span><br>        nlmsghdr* hdr = reinterpret_cast&lt;nlmsghdr*&gt;(data_);<br><br>        <span class="hljs-comment">// 遍历缓冲区中可能包含的多条 Netlink 消息</span><br>        <span class="hljs-keyword">for</span> (; NLMSG_OK(hdr, static_cast&lt;<span class="hljs-type">size_t</span>&gt;(bytes_read));<br>               hdr = NLMSG_NEXT(hdr, bytes_read)) &#123;<br>            <span class="hljs-comment">// 如果遇到 NLMSG_DONE，表示所有数据已结束，返回成功</span><br>            <span class="hljs-keyword">if</span> (hdr-&gt;nlmsg_type == NLMSG_DONE)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>            <span class="hljs-comment">// 如果遇到错误消息 NLMSG_ERROR，提取错误码并返回失败</span><br>            <span class="hljs-keyword">if</span> (hdr-&gt;nlmsg_type == NLMSG_ERROR) &#123;<br>                <span class="hljs-comment">// 获取错误结构体指针</span><br>                nlmsgerr* err = reinterpret_cast&lt;nlmsgerr*&gt;(NLMSG_DATA(hdr));<br>                <span class="hljs-comment">// 如果报文长度足够，使用内核返回的负错误码；否则设为 I/O 错误</span><br>                errno = (hdr-&gt;nlmsg_len &gt;= NLMSG_LENGTH(<span class="hljs-keyword">sizeof</span>(nlmsgerr)))<br>                            ? -err-&gt;error<br>                            : EIO;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 对于其他类型的消息，调用用户传入的回调处理</span><br>            callback(context, hdr);<br>        &#125;<br>        <span class="hljs-comment">// 循环继续，直到 recv 返回 &lt;= 0 或者遇到 NLMSG_DONE/NLMSG_ERROR</span><br>    &#125;<br><br>    <span class="hljs-comment">// 如果在看到 NLMSG_DONE 之前，recv 出错或返回 0，就当作失败</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>作者认为原来的使用netlinker通信使用recv容易被直接hook，故给出了两种方法</p>
<p>在不直接使用系统提供的recv 以后</p>
<ul>
<li><p>方法1：直接调用syscall函数，通过syscall函数进行切入到recv</p>
</li>
<li><p>方法2：我们直接把recv换成svc内联汇编代码如下<br>  相当于自己实现syscall （代码摘抄自libc syscall）</p>
</li>
</ul>
<p>但是方法2存在弊端</p>
<p>安卓8内核上使用了seccomop 过滤掉了svc 直接调用 recv</p>
<p>对此，解决办法是直接通过<strong>libc的syscall()进行调用</strong></p>
<p>下面是AI给我生成的流程图</p>
<p><strong>修改前 (被拦截路径)：</strong></p>
<p><img src="D:\题目\deepseek_mermaid_20250530_d8094a.png" srcset="/\img\A008779F61D12BE23A64C76080892F5C.jpg" lazyload alt="deepseek_mermaid_20250530_d8094a"></p>
<p><strong>修改后：</strong></p>
<p><img src="D:\题目\deepseek_mermaid_20250530_136373.png" srcset="/\img\A008779F61D12BE23A64C76080892F5C.jpg" lazyload alt="deepseek_mermaid_20250530_136373"></p>
<p>最后代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">NetlinkConnection::ReadResponses</span><span class="hljs-params">(<span class="hljs-type">void</span> callback(<span class="hljs-type">void</span>*, nlmsghdr*), <span class="hljs-type">void</span>* out)</span> &#123;<br>  <span class="hljs-comment">// Read through all the responses, handing interesting ones to the callback.</span><br>  <span class="hljs-type">ssize_t</span> bytes_read;<br><br><span class="hljs-keyword">while</span> ((bytes_read = TEMP_FAILURE_RETRY(raw_syscall(__NR_recvfrom,fd_, data_, size_, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>))) &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">auto</span>* hdr = reinterpret_cast&lt;nlmsghdr*&gt;(data_);<br>    <span class="hljs-keyword">for</span> (; NLMSG_OK(hdr, static_cast&lt;<span class="hljs-type">size_t</span>&gt;(bytes_read)); hdr = NLMSG_NEXT(hdr, bytes_read)) &#123;<br><br>      <span class="hljs-keyword">if</span> (hdr-&gt;nlmsg_type == NLMSG_DONE) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      <span class="hljs-keyword">if</span> (hdr-&gt;nlmsg_type == NLMSG_ERROR) &#123;<br>        <span class="hljs-keyword">auto</span>* err = reinterpret_cast&lt;nlmsgerr*&gt;(NLMSG_DATA(hdr));<br>        errno = (hdr-&gt;nlmsg_len &gt;= NLMSG_LENGTH(<span class="hljs-keyword">sizeof</span>(nlmsgerr))) ? -err-&gt;error : EIO;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>      <span class="hljs-comment">//处理具体逻辑</span><br>      callback(out, hdr);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// We only get here if recv fails before we see a NLMSG_DONE.</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Android/" class="print-no-link">#Android</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>通过netlinker和svc获取mac地址解析</div>
      <div>http://example.com/2025/05/30/netlinker/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年5月30日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/09/28/%E5%A4%A9%E5%A0%82%E4%B9%8B%E9%97%A8%E5%AD%A6%E4%B9%A0/" title="天堂之门——WoW64学习">
                        <span class="hidden-mobile">天堂之门——WoW64学习</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
