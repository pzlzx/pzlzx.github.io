<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>PE文件的块</title>
    <link href="/2024/03/05/PE%E6%96%87%E4%BB%B6%E7%9A%84%E5%9D%97/"/>
    <url>/2024/03/05/PE%E6%96%87%E4%BB%B6%E7%9A%84%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="PE文件的块"><a href="#PE文件的块" class="headerlink" title="PE文件的块"></a>PE文件的块</h1><p>PE文件使用的是一个平面的地址空间，所有的代码和数据都被合并在一起，组成一个很大的结构，文件的内容被分为很多的块，块中包含代码和数据，在排列位置上，在PE文件的DOS头部和PE文件头之后就是块表和多个不同的块，（Section,又称为节，区块，区段）</p><h2 id="Windows是如何将PE文件映射到内存中的："><a href="#Windows是如何将PE文件映射到内存中的：" class="headerlink" title="Windows是如何将PE文件映射到内存中的："></a>Windows是如何将PE文件映射到内存中的：</h2><h6 id="在执行一个PE文件时，Windows并不在一开始就将整个文件读入内存，而是采用与内存映射文件类似的机制，也就是说windows装载器在装载的时候仅仅建立好虚拟地址与PE文件的映射关系，只有真正执行到某个内存页指令或者访问页中数据时，这个页面才会被从磁盘提交到物理内存"><a href="#在执行一个PE文件时，Windows并不在一开始就将整个文件读入内存，而是采用与内存映射文件类似的机制，也就是说windows装载器在装载的时候仅仅建立好虚拟地址与PE文件的映射关系，只有真正执行到某个内存页指令或者访问页中数据时，这个页面才会被从磁盘提交到物理内存" class="headerlink" title="在执行一个PE文件时，Windows并不在一开始就将整个文件读入内存，而是采用与内存映射文件类似的机制，也就是说windows装载器在装载的时候仅仅建立好虚拟地址与PE文件的映射关系，只有真正执行到某个内存页指令或者访问页中数据时，这个页面才会被从磁盘提交到物理内存"></a>在执行一个PE文件时，Windows并不在一开始就将整个文件读入内存，而是采用与内存映射文件类似的机制，也就是说windows装载器在装载的时候仅仅建立好虚拟地址与PE文件的映射关系，只有真正执行到某个内存页指令或者访问页中数据时，这个页面才会被从磁盘提交到物理内存</h6><p>这种机制使文件装入的速度和文件大小没有关系，但是需要注意的是系统装载可执行文件的方法又不完全等同于内存映射文件，在装载前，有些数据会发生预处理，比如重定位，所以，数据之间的相对位置可能发生轻微变化</p><p>windows装载器在装载PE文件时的DOS头部，PE文件头和块表部分不会做任何处理，而在装载块时根据块的属性做不同的处理</p><p>块的偏移：块在磁盘文件中是按照可选映像头结构中的FileAlignment字段的值对齐的，而被装载到内存中是按照可选映像头结构中的SectionAlignment字段的值对齐的。所以一个块被装入内存后相对于文件头的偏移和1磁盘文件的偏移是不同的。</p><p>重点块♥：</p><p>.text:代码块，内容全是指令代码。在编译或者汇编结束产生的一种块</p><p>.data：读&#x2F;写数据块，一般存放全局变量和静态变量，是初始化的数据块</p><p>.rdata:只读数据块，用于存放调试目录和说明字符串，是运行期只读的数据</p><p>.idata:输入表，包含其他的DLL的函数及数据信息，有的编译器会将这个块合并到.rdata块</p><p>.edata:输入表，创建一个输出API或数据的可执行文件时，会用到此块</p><p>.rsrc:资源快，包含模块的全部资源，如图标，菜单，位图等</p><p>IMAGE_SECTION_HEADER长度为40个字节</p><p>PE文件头的最后部分——可选映像头的数据目录表：位于128h到117h之间</p><p>可在LoadPE中选择区段来查看区段表</p><h1 id="PE文件的输入和输出表"><a href="#PE文件的输入和输出表" class="headerlink" title="PE文件的输入和输出表"></a>PE文件的输入和输出表</h1><p>一个windows程序基本上所实现的所有功能几乎都是直接调用系统dll提供的API函数实现的，要使用任何一个dll所提供的函数，我们需要将它导入，也就是用到了输入表，输入表在软件外壳基础中十分重要对于那些提供了被导出函数的dll程序来说，它们必须使用输出表将函数输出之后别的程序才可以使用</p><p>无论是自己编写的dll还是系统提供的标准dll，只要想要提供函数给别人使用，就一定要建立输出表，一般的开发环境都能编写具有输出功能的程序，输出表都是由链接器之中建立的，我们只需要指定被输出函数的名称或者序号就可以了，输出表通常出现在dll文件的edata中。</p><h5 id="IT"><a href="#IT" class="headerlink" title="IT:"></a>IT:</h5><p>可执行文件使用来自于其他DLL的代码或数据时，称为输入。当PE文件装载到内存时，windows加载器的工作之一就是定位所有被输入的函数和数据，并且让正在被装入的文件可以使用那些地址。这个过程是通过PE文件的输入表（Import Table ，简称IT，又称为导入表）来完成的，输入表中保存的是函数名和其驻留dll名等动态连接所需要的信息。</p><h5 id="IAT"><a href="#IAT" class="headerlink" title="IAT:"></a>IAT:</h5><p>在PE文件中，有一组数据结构，它们分别对应着每个被输入的dll，每一个这样的结构都给出了被输入的dll名称并指向一组函数指针。这组函数指针被称为输入地址表（Import Address Table,简称IAT)。每一个被引入的API在IAT里都有它自己的保留位置，在那里它将被windows装载器写入输入函数的地址，一旦模块被装入，IAT中包含所要调用输入函数的地址。</p><h5 id="IID："><a href="#IID：" class="headerlink" title="IID："></a>IID：</h5><p>PE文件头的可选映像头中，数据目录表的第二个成员指向输入表，输入表以一个IMAGE_IMPORT_DESCRIPTOR（简称IID)数组开始。每个被PE文件隐式地链接进来的DLL都有一个IID。在这个数组中，没有字段指出该数组结构的项数，但是它的最后一个单元是NULL，由此计算出该数组的项数。</p><p>例如，某个PE文件从两个DLL文件中引入函数，就存在两个IID结构来描述这些DLL文件，并在两个IID结构的最后一个内容全为0的IID结构作为结束。</p><p>每个IID结构的长度是5个双字，即20个字节。</p><p>每个IMAGE_IMPORT_DESCRIPOR(简称IID)结构定义如下：（部分）</p><p>IMAGE_IMPORT_DESCRIPOR STRUCT{</p><p>UNION</p><p>Characteristics dd?</p><p>OriginalFirstThunk dd? &#x2F;&#x2F;指向INT（输入名称表），为RVA</p><p>Ends</p><p>TimeDateStamp dd? &#x2F;&#x2F;32位</p><p>ForwaderChain dd? &#x2F;&#x2F;转向索引，一般为0</p><p>Name dd？ &#x2F;&#x2F;指向DLL名称的RVA值，如“kernel32.dll”</p><p>FirstThunk dd? &#x2F;&#x2F;指向IAT（输入地址表）的RVA值</p><p>IMAGE_IMPORT_DESCRIPOR STRUCT ENDS}</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202403052057177.png" alt="image-20240304223655245"></p><p>OriginalFirstThunk 与FirstThunk非常相似，它们指向两个本质上相同的IMAGE_THUNK_DATA的结构的数组。一般来说，OriginalFirstThunk 指向的 IMAGE_THUNK_DATA的结构数据称为输入名称表，（Import Name Table—-INT),FirstThunk指向的数据结构数组称为输入地址表（Import Address Table–IAT)</p><p><img src="https://img-blog.csdn.net/20151218122416073?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>IMAGE_THUNK_DATA结构的数组中，每个元素对应于一个从可执行文件输入的函数，数组结构的结束也是通过一个全为0的元素作为标识。</p><p>在IMAGE_THUNK_DATA中的ForwarderString指向一个转向字符的RVA值，Function是被输入函数的内存地址，ordinal是被输入函数的API的序数值，AddressOfData指向IMAGE_IMPORT_BY_NAME</p><p>ordinal和addressofdata什么时候使用？</p><p>当IMAGE_THUNK_DATA类型的数据的最高位为1的时候，代表函数以序号的方式导入，ordinal的低31位就是输入函数在其DLL内的导出序号</p><p>当IMAGE_THUNK_DATA类型的数据最高位为0的时候，代表函数以字符串方式导入，这时AddressOfData就是一个指向用来导入函数名称的IMAGE_IMPORT_BY_NAME的数据结构的RVA</p><p>typedef struct _IMAGE_IMPORT_BY_NAME {<br>        WORD Hint; &#x2F;&#x2F;函数序号，不是必须的</p><p>​BYTE Name[1];&#x2F;&#x2F;导入函数名称，为以0结尾的ASCII字串<br>} </p><p>IMAGE_IMPORT_BY_NAME ENDS</p><p>这里的NAME大小是一个可变的尺寸域</p><p>数据目录表位于128h到1A7h之间，每个成员占8个字节，分别指向相关的结构，</p><p>第一个八个字节指向输出表，如果全部为0，这个文件的地址和大小都是0，表示没有输出表</p><p>地址130h-137h是数据目录表第二项，指向输入表，输入表的前四个字节是一个相对虚拟地址（注意小端序存放地址，这个地方不是实际地址也不是偏移量），后4个字节是大小</p><p>LordPE位置计算器可以用来计算偏移量</p>]]></content>
    
    
    
    <tags>
      
      <tag>RE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2023-2024 上学期寒假假期学习总结</title>
    <link href="/2024/03/04/2023-2024%20%E4%B8%8A%E5%AD%A6%E6%9C%9F%E5%AF%92%E5%81%87%E5%81%87%E6%9C%9F%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <url>/2024/03/04/2023-2024%20%E4%B8%8A%E5%AD%A6%E6%9C%9F%E5%AF%92%E5%81%87%E5%81%87%E6%9C%9F%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="2023-2024-上学期寒假假期学习总结"><a href="#2023-2024-上学期寒假假期学习总结" class="headerlink" title="2023-2024 上学期寒假假期学习总结"></a>2023-2024 上学期寒假假期学习总结</h1><h5 id="这个假期先是学习了下linux的指令（参考韩顺平b站课程），没有特别多的实操，常用指令还是可以了，"><a href="#这个假期先是学习了下linux的指令（参考韩顺平b站课程），没有特别多的实操，常用指令还是可以了，" class="headerlink" title="这个假期先是学习了下linux的指令（参考韩顺平b站课程），没有特别多的实操，常用指令还是可以了，"></a>这个假期先是学习了下linux的指令（参考韩顺平b站课程），没有特别多的实操，常用指令还是可以了，</h5><h5 id="java看课看了大概50节（总共900多节……嘶），感觉看了就是看了，之前其实上学的时候大概十一月吧浅看过的，当时速通了一晚上起来感觉还是要实践一下才行，害，安卓！然后配了下相应环境"><a href="#java看课看了大概50节（总共900多节……嘶），感觉看了就是看了，之前其实上学的时候大概十一月吧浅看过的，当时速通了一晚上起来感觉还是要实践一下才行，害，安卓！然后配了下相应环境" class="headerlink" title="java看课看了大概50节（总共900多节……嘶），感觉看了就是看了，之前其实上学的时候大概十一月吧浅看过的，当时速通了一晚上起来感觉还是要实践一下才行，害，安卓！然后配了下相应环境"></a>java看课看了大概50节（总共900多节……嘶），感觉看了就是看了，之前其实上学的时候大概十一月吧浅看过的，当时速通了一晚上起来感觉还是要实践一下才行，害，安卓！然后配了下相应环境</h5><h5 id="假期IDA寄了一下，然后搞了7-6，7-7，8-3的IDA-当时是做begin-ctf的那个xor题发现字符串无法显示，换了很多版本开都不太行，有点影响对程序里面加密函数的追踪了，然后就想着把这个问题解决了（后来看其他人是一直交叉引用找到main函数还是啥），看了一部分wp好像就是说那个题目最好拿8-3的开，但是当时还是不知道，在网上把方法那些都试过了还是不太行。"><a href="#假期IDA寄了一下，然后搞了7-6，7-7，8-3的IDA-当时是做begin-ctf的那个xor题发现字符串无法显示，换了很多版本开都不太行，有点影响对程序里面加密函数的追踪了，然后就想着把这个问题解决了（后来看其他人是一直交叉引用找到main函数还是啥），看了一部分wp好像就是说那个题目最好拿8-3的开，但是当时还是不知道，在网上把方法那些都试过了还是不太行。" class="headerlink" title="假期IDA寄了一下，然后搞了7.6，7.7，8.3的IDA,当时是做begin ctf的那个xor题发现字符串无法显示，换了很多版本开都不太行，有点影响对程序里面加密函数的追踪了，然后就想着把这个问题解决了（后来看其他人是一直交叉引用找到main函数还是啥），看了一部分wp好像就是说那个题目最好拿8.3的开，但是当时还是不知道，在网上把方法那些都试过了还是不太行。"></a>假期IDA寄了一下，然后搞了7.6，7.7，8.3的IDA,当时是做begin ctf的那个xor题发现字符串无法显示，换了很多版本开都不太行，有点影响对程序里面加密函数的追踪了，然后就想着把这个问题解决了（后来看其他人是一直交叉引用找到main函数还是啥），看了一部分wp好像就是说那个题目最好拿8.3的开，但是当时还是不知道，在网上把方法那些都试过了还是不太行。</h5><p>也收获了一些经验（虽然解决不了当时那个问题）：</p><p>1.多试几个版本的IDA开，一个不行换另外一个</p><p>2.重新开机</p><p>3.点一下这几个dll<img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202403041755958.png" alt="4B43930D53D2B5C0047D7799A56D7E52"></p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202403041755565.png" alt="CC5EC185CA4FBF54A9D6797C916DBAAE"></p><p>4.把IDA里面的字体设置(options–&gt;general–&gt;strings)的UTF-8换成CP936,在字符串界面全选后右键rebuild,然后左下角</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202403041759478.png" alt="image-20240304175943442"></p><p>然后再次全选rebuild，然后就出来了</p><h5 id="西湖论剑看了看题，还未复现，复现有一点点卡"><a href="#西湖论剑看了看题，还未复现，复现有一点点卡" class="headerlink" title="西湖论剑看了看题，还未复现，复现有一点点卡"></a>西湖论剑看了看题，还未复现，复现有一点点卡</h5><h5 id="对着b站的课又学了下汇编，发现自己以前对汇编部分的指令的理解出现了一些偏差，算是复习"><a href="#对着b站的课又学了下汇编，发现自己以前对汇编部分的指令的理解出现了一些偏差，算是复习" class="headerlink" title="对着b站的课又学了下汇编，发现自己以前对汇编部分的指令的理解出现了一些偏差，算是复习"></a>对着b站的课又学了下汇编，发现自己以前对汇编部分的指令的理解出现了一些偏差，算是复习</h5><p>花指令：</p><p>xor ebx,ebx </p><p>test ebx </p><p>jz label1 </p><p>jnz label2 </p><p>由于上一步已经将EBX设为0，所以ZF标志位会被设置。因此，接着执行”jz label1”指令，跳转到label1处</p><h5 id="beginctf做了一些题（未复现完，第一次做vm），搞了下真机调试"><a href="#beginctf做了一些题（未复现完，第一次做vm），搞了下真机调试" class="headerlink" title="beginctf做了一些题（未复现完，第一次做vm），搞了下真机调试"></a>beginctf做了一些题（未复现完，第一次做vm），搞了下真机调试</h5><h5 id="hgame-week2-和-week3-复现，感觉还是写的比较详细吧"><a href="#hgame-week2-和-week3-复现，感觉还是写的比较详细吧" class="headerlink" title="hgame week2 和 week3 复现，感觉还是写的比较详细吧"></a>hgame week2 和 week3 复现，感觉还是写的比较详细吧</h5><h5 id="博客重新整了一下，因为距第一次上传太久了，后面惊讶发现自己上传文章以后在博客网页点开文章后显示页面不存在，后面发现是因为md文章里面标题的名字大小写和md文章本身名字不一样，然后注意最上方加粗的格式里面的冒号不是中文的"><a href="#博客重新整了一下，因为距第一次上传太久了，后面惊讶发现自己上传文章以后在博客网页点开文章后显示页面不存在，后面发现是因为md文章里面标题的名字大小写和md文章本身名字不一样，然后注意最上方加粗的格式里面的冒号不是中文的" class="headerlink" title="博客重新整了一下，因为距第一次上传太久了，后面惊讶发现自己上传文章以后在博客网页点开文章后显示页面不存在，后面发现是因为md文章里面标题的名字大小写和md文章本身名字不一样，然后注意最上方加粗的格式里面的冒号不是中文的"></a>博客重新整了一下，因为距第一次上传太久了，后面惊讶发现自己上传文章以后在博客网页点开文章后显示页面不存在，后面发现是因为md文章里面标题的名字大小写和md文章本身名字不一样，然后注意最上方加粗的格式里面的冒号不是中文的</h5><p>最后又重新传了一遍，不知道为什么以前传的头像和背景都没了，然后又拖了段时间实在受不了了（其实是看别人博客都很好看……），然后重新传了一下（虽然现在也就只有首页能看吧），注意编辑yml的时候不要用”\“应该用“&#x2F;”，然后因为之前配置图片是在img文件夹下面发现没有用，网上搜也没有很具体，最后试出来是在blog\public最后下面的img里面配置图片，然后编辑yml界面的时候的相对路径写这个就可以了</p><p>看了些别人写的博客</p><h5 id="nss还是做了点小题，polar也做了一些感觉确实题目有些出的比较奇怪（可忽略）"><a href="#nss还是做了点小题，polar也做了一些感觉确实题目有些出的比较奇怪（可忽略）" class="headerlink" title="nss还是做了点小题，polar也做了一些感觉确实题目有些出的比较奇怪（可忽略）"></a>nss还是做了点小题，polar也做了一些感觉确实题目有些出的比较奇怪（可忽略）</h5><h5 id="逆向工程核心原理搞到第一部分，但是后期因为对windows方面知识储备不足所以有所卡顿"><a href="#逆向工程核心原理搞到第一部分，但是后期因为对windows方面知识储备不足所以有所卡顿" class="headerlink" title="逆向工程核心原理搞到第一部分，但是后期因为对windows方面知识储备不足所以有所卡顿"></a>逆向工程核心原理搞到第一部分，但是后期因为对windows方面知识储备不足所以有所卡顿</h5><h5 id="工具方面都很粗略看了下，网课，docker-cmake-git-正则表达式，IDA特训营（看了一些没有看完，有些想实践一下实在没有找到对应的题）"><a href="#工具方面都很粗略看了下，网课，docker-cmake-git-正则表达式，IDA特训营（看了一些没有看完，有些想实践一下实在没有找到对应的题）" class="headerlink" title="工具方面都很粗略看了下，网课，docker,cmake,git,正则表达式，IDA特训营（看了一些没有看完，有些想实践一下实在没有找到对应的题）"></a>工具方面都很粗略看了下，网课，docker,cmake,git,正则表达式，IDA特训营（看了一些没有看完，有些想实践一下实在没有找到对应的题）</h5><p>目前感觉好像没有怎么用到上面的工具所以还是很生疏感觉会忘，感觉学的很浅</p><h5 id="很粗浅的看了一点点计网的东西，然后接触了点点简单的Misc"><a href="#很粗浅的看了一点点计网的东西，然后接触了点点简单的Misc" class="headerlink" title="很粗浅的看了一点点计网的东西，然后接触了点点简单的Misc"></a>很粗浅的看了一点点计网的东西，然后接触了点点简单的Misc</h5><p>然后这个假期差不多就这样了，偶尔还是会有点焦虑，想个题想半天搞不出来有点自闭，不过幸好最后都解决了，这个学期的目标是争取按板块完善自己RE方面的知识储备，还没有开始pwn，还是希望后期自己能稳住心态，学踏实一点吧</p><p>新学期加油💪</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024第一周学习笔记</title>
    <link href="/2024/03/03/2024%20%E7%AC%AC%E4%B8%80%E5%91%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/03/03/2024%20%E7%AC%AC%E4%B8%80%E5%91%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="2024-第一周学习笔记"><a href="#2024-第一周学习笔记" class="headerlink" title="2024 第一周学习笔记"></a>2024 第一周学习笔记</h1><p>壳：分为两种，一种是压缩壳1，一种是加密壳</p><p>用IDA打开加壳后的文件</p><p>使用 IDA 打开时会提示 <code>Some imported modules will not be visible because the IAT is located outside of memory range of the input file.</code></p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202403031724361.png" alt="img"></p><h2 id="手动脱壳三种方法："><a href="#手动脱壳三种方法：" class="headerlink" title="手动脱壳三种方法："></a>手动脱壳三种方法：</h2><h3 id="1-单步跟踪法"><a href="#1-单步跟踪法" class="headerlink" title="1.单步跟踪法"></a>1.单步跟踪法</h3><h5 id="原则：向上的跳转，不执行，向下的跳转执行，灰色的不用管"><a href="#原则：向上的跳转，不执行，向下的跳转执行，灰色的不用管" class="headerlink" title="原则：向上的跳转，不执行，向下的跳转执行，灰色的不用管"></a>原则：向上的跳转，不执行，向下的跳转执行，灰色的不用管</h5><p>单步运行程序，当发现程序向下运行时有向上跳转的箭头时，在程序的下一步（即下一行）设置断点，然后不进行向上的跳转</p><p>步骤：</p><p>法一：右键选中，断点–&gt;运行到选定位置（F4）</p><p>法二：右键选中，断点–&gt;切换，然后运行，最后再点击切换来取消这个断点</p><p>注意：</p><p>当此时下一行的指令还是跳转时(JZ JNZ CALL)，则继续选择下一行进行跳转</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202403031533234.png" alt="image-20240303153301086"></p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202403031450046.png"></p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202403031538280.png" alt="image-20240303153848169"></p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202403031540308.png" alt="image-20240303154057257"></p><p>脱壳方式有两种：一种是使用od插件ollydump，另一种是使用工具lordpe</p><p>od插件又有两种，一种是方式一，一种是方式二</p><p>进入OEP，可以进行脱壳了</p><p>使用ollydump脱壳调试进程</p><p>lordpe:（这个看上去好像有点麻烦，浅记一下）</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202403031547434.png" alt="image-20240303154743390"></p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202403031550982.png" alt="image-20240303155052911"></p><p>查看相对基址（上图中的OEP）可以使用下图方法，点击后在修正值处的值就是我们所需要的OEP的值</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202403031550212.png" alt="image-20240303155015170"></p><h2 id="2-一步直达法"><a href="#2-一步直达法" class="headerlink" title="2.一步直达法"></a>2.一步直达法</h2><p>说明：适用于绝大部分的upx壳和aspack壳</p><p>进入OD，使用Ctrl+F搜索出popad（搜索时不要勾选”整个块“这个选项），然后使用跳转，跳转到此处，然后F8进入OEP，开始使用ollydump脱壳</p><h2 id="3-ESP定律脱壳"><a href="#3-ESP定律脱壳" class="headerlink" title="3.ESP定律脱壳"></a>3.ESP定律脱壳</h2><p>使用快捷键F8，单步一次，发现只有ESP寄存器是红的，就可以使用ESP定律</p><p>右键选择数据窗口跟随，设置断点</p><p>F9运行</p><p>F8进入OEP，此处如果是push ebp,就是进入了OEP</p><p>开始使用OD的插件脱壳</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202403031507844.png" alt="image-20240303150734726"></p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202403031508296.png" alt="image-20240303150833144"></p><p>这个地方设置断点的时候dword和word都一样</p><h2 id="4-内存镜像法"><a href="#4-内存镜像法" class="headerlink" title="4.内存镜像法"></a>4.内存镜像法</h2><p>右上角点击查看–&gt;内存</p><p>找程序出现的第一个rsrc</p><p>总结：</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202403031611904.png" alt="image-20240303161111876"></p><p><a href="https://blog.csdn.net/sirrior/article/details/134597589">upx手动脱壳学习笔记_如何使用upx脱壳-CSDN博客</a></p><p><a href="https://blog.csdn.net/m0_46296905/article/details/116049504">UPX手动脱壳-CSDN博客</a></p><h2 id="使用bindiff对去符号化题目进行处理报错处理"><a href="#使用bindiff对去符号化题目进行处理报错处理" class="headerlink" title="使用bindiff对去符号化题目进行处理报错处理"></a>使用bindiff对去符号化题目进行处理报错处理</h2><p>打开文件</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202403031653064.JPG" alt="FF1F28C59D5D07660321030BB8F66733"></p><p>据说最开始第一个报错没有什么具体影响</p><p>但是第二个报错有，会影响接下来对文件的分析</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202403031651240.png" alt="image-20240302115416240"></p><p>网上好像也没有找到相应的解决办法，最后试了很久找到两个方法：</p><p>法一：</p><p>手动拖动，按下import symbols</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202403031657326.png" alt="img"></p><p>然后在一旁的汇编框内按下f5</p><p>法二：</p><p>尝试更换bindiff的插件，bindiff</p><p>BinDiff 7 通常与 IDA Pro 7.x 版本兼容，7的版本似乎只适用于IDA7.6，在github上面重新下载一个Bindiff，然后在</p><p>C:\Users\asus\AppData\Roaming\Hex-Rays\IDA Pro\plugins下替换掉原来的Bindiff插件（放在一个公共插件存放的位置）</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202403031708317.png" alt="image-20240303170808277"></p><h2 id="青少年ctf-re复现"><a href="#青少年ctf-re复现" class="headerlink" title="青少年ctf re复现"></a>青少年ctf re复现</h2><p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20240303235625824.png" alt="image-20240303235625824"></p><p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20240304000021168.png" alt="image-20240304000021168"></p>]]></content>
    
    
    
    <tags>
      
      <tag>RE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hagme week3 RE wp</title>
    <link href="/2024/02/24/hagme%20week3%20RE%20wp/"/>
    <url>/2024/02/24/hagme%20week3%20RE%20wp/</url>
    
    <content type="html"><![CDATA[<h1 id="hagme-week3-RE-wp"><a href="#hagme-week3-RE-wp" class="headerlink" title="hagme week3 RE wp"></a>hagme week3 RE wp</h1><h2 id="mystery"><a href="#mystery" class="headerlink" title="mystery"></a>mystery</h2><p>用ida打开题目发现main函数界面只有ptrace反调试函数，搜索字符串可定位</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402241400204.png" alt="image-20240224140048114"></p><p>用7打开大概是这样的（wp上那种）</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402241427676.png" alt="image-20240224142704607"></p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402241427821.png" alt="image-20240224142722779"></p><p>用8开会好看很多，即主要逻辑（可直接通过字符串定位）</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402262103486.png" alt="image-20240226210346347"></p><p>可以看到这里两个函数都有unk_4080</p><p>交叉引用</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402262106382.png" alt="image-20240226210629311"></p><p>打开func2，因为题目为elf文件，发现func2在初始化函数里面，可以得知rc4加密的密钥在初始化时被修改</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402262120942.png" alt="image-20240226212051860"></p><p>所以执行顺序为func2——&gt;func1</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402262319003.png" alt="image-20240226231945892"></p><p>动调获取Key的值</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402270103013.png" alt="屏幕截图 2024-02-27 010131"></p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402270106267.png" alt="image-20240227010609229"></p><h2 id="Encrypt"><a href="#Encrypt" class="headerlink" title="Encrypt"></a>Encrypt</h2><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/seccng/encrypting-data-with-cng">使用 CNG 加密数据 - Win32 apps | Microsoft Learn</a></p><p>首先通过一系列函数调用设置算法属性、生成对称密钥并导出密钥，如果这些函数都成功执行，则进入条件判断语句的大括号内部。</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402261422929.png" alt="image-20240226142233845"></p><p>获得key</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402261450940.png" alt="image-20240226145038903"></p><p>又因为</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402261456165.png" alt="image-20240226145603116"></p><p>这里v6&#x3D;v11</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402261458867.png" alt="image-20240226145839824"></p><p>其中memcpy(v11, &amp;unk_1400034A0, *(unsigned int *)v26)将定数据（unk_1400034A0）复制到 v11 指向的内存块中</p><p>所以找到IV</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402261501326.png" alt="image-20240226150100286"></p><p>获取数据然后转换下形式</p><p>key:4c9d7b3eecd0661fa034dc863f5f1fe2</p><p>iv:936af225fa6810b8d07c3e5e9ee8ee0d</p><p>input：</p><p>A4E10F1C53BC42CD8E7154B7F175E35097207197A83B7761406968C1B47B88549F19034470782425F0A96535913A049C4E66BED28B8B2073CEA0CBE939BD6D83</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402261557621.png" alt="image-20240226155706564"></p><p>hgame{rever5e_wind0ws_4P1_is_1nter3sting}</p><p>下面是当时看的一些函数</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402261401558.png" alt="image-20240226140054441"></p><ol><li>通过调用<code>BCryptOpenAlgorithmProvider</code>函数，使用AES算法初始化一个算法提供程序句柄。</li><li>使用<code>BCryptGetProperty</code>函数和属性<code>BCRYPT_OBJECT_LENGTH</code>确定密钥对象缓冲区的大小。</li><li>使用<code>HeapAlloc</code>为密钥对象缓冲区（<code>pbKeyObject</code>）分配内存。</li><li>使用<code>BCryptGenerateSymmetricKey</code>函数，使用算法提供程序句柄、密钥对象缓冲区、密钥长度和密钥数据生成密钥。</li></ol><h2 id="findme"><a href="#findme" class="headerlink" title="findme"></a>findme</h2><p>打开文件然后发现Buffer</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402251741675.png" alt="image-20240225174156609"></p><p>发现数据里面有MZ和90，合理怀疑这个地方藏的是一个exe的数据</p><p>（Windows下的exe文件格式有两种：MZ格式、PE格式。MZ格式为较早的exe文件格式，主要用于DOS系统。PE格式是目前Windows下常见的exe文件格式，它兼容MZ格式，本身也是一个MZ格式的可执行文件。）</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402251743392.png" alt="image-20240225174311353"></p><p>经尝试，直接获取里面的数据失败，采用脚本获取#include &lt;stdio.h&gt;<br><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402251747372.png" alt="image-20240225174726335"></p><p>将该脚本的exe与题目放在同一个文件夹下后运行，然后生成一个real.exe的文件1，即为要真正分析的文件</p><p>打开生成的real.exe，注意这个是32位的😂手动去花</p><p>这个地方复习一下花指令，jz和jnz永远跳转类型，把junkcode nop掉</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402251955327.png" alt="image-20240225195501289"></p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402251800849.png" alt="image-20240225180049816"></p><p>然后选中后c识别代码，p创建函数，f5反汇编得到正常逻辑代码</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402251949912.png" alt="image-20240225194915865"></p><p>这个题直接找加密算法找不到</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402251957276.png" alt="image-20240225195706218"></p><p>可以看出第一个循环在初始化s盒 byte_403390，改变量名，好看</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402252005446.png" alt="image-20240225200545389"></p><p>func2:使用上述func1初始化好的数组 <code>s</code> 进行加密操作</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402252024849.png" alt="image-20240225202401793"></p><p>flag长度为32，则构造一个32的数据进行动调</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402252117679.png" alt="image-20240225211757624"></p><p><a href="https://blog.csdn.net/xiao__1bai/article/details/123357156">解析 RC4 加密算法(C语言、python)-CSDN博客</a></p><p>这个地方涉及到下标越界的问题,可以直接采用动调每次步过记录result的值（感觉有点麻烦）</p><h5 id="exp"><a href="#exp" class="headerlink" title="exp:"></a>exp:</h5><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402252151072.png" alt="image-20240225215140982"></p><p>hgame{Fl0w3rs_Ar3_Very_fr4grant}</p><h2 id="Crackme"><a href="#Crackme" class="headerlink" title="Crackme"></a>Crackme</h2><p>定位找到main函数</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402252216477.png" alt="image-20240225221645408"></p><p>（<code>std::exception</code> 是一个 C++ 标准库中的基类，用于表示所有标准异常类的基类。它定义了一个名称为 <code>what()</code> 的虚函数，用于返回一个 C 字符串，即异常的描述信息。因此，如果你在代码中看到某个异常类型是 <code>std::exception</code>，那么可以认为这个异常类型是一个通用的、基础的异常类型，表示出现了未知的异常情况。通常情况下，具体的异常类型应该是 <code>std::exception</code> 的派生类，以便更好地表达出具体异常的类型和描述信息，从而更好地处理异常情况。）</p><p>在 C++ 中，<code>try</code> 和 <code>catch</code> 是用于异常处理的关键字，<code>try</code> 用于尝试执行可能会抛出异常的代码块，而 <code>catch</code> 则用于捕获并处理抛出的异常。</p><p>动调</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402261631856.png" alt="image-20240226163152814"></p><p>单步一下，然后发现报错</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402261632531.png" alt="image-20240226163233471"></p><p>（解释：这是一个 Windows 操作系统的错误提示信息，指示一个程序在执行时遇到了问题。具体而言，错误信息表明程序尝试读取内存中的某个位置，但该内存位置的值为 0xFFFFFFFFFFFFFFFF，也就是无效的内存地址。由于该内存地址无法访问，程序无法读取该内存位置的数据，从而导致了错误。错误代码 “c0000005” 是 Windows 中的通用异常代码，通常表示由于访问违反了内存保护或者其他原因，导致了应用程序终止的问题。线程 ID (tid) “88396” 表示在哪个线程中发生了错误。）</p><p>tab然后发现只有try的汇编代码，没有catch的，所以把这3个连续的catch函数给dump（shift + E)下来</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402261826951.png" alt="image-20240226182658873"></p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402261835104.png" alt="image-20240226183515040"></p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402261835701.png" alt="image-20240226183540637"></p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402261836269.png" alt="image-20240226183600212"></p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402261837735.png" alt="image-20240226183755642"></p><p>export后在文件所在文件夹下生成含该数据的txt</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402272128029.png" alt="image-20240227212814904"></p><p>emmmm winhex没试出来</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402272143386.png" alt="image-20240227214307333"></p><p>打开010editor选择十六进制导入——另存为（不要后缀名）——导出——得到文件</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402272158291.png" alt="image-20240227215842231"></p><p>全选以后p创建函数然后F5反汇编，得到加密代码</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402261947804.png" alt="image-20240226194731643"></p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402261948791.png" alt="image-20240226194802727"></p><p>hgame{C_p1us_plus_exc3pti0n!!!!}</p><h5 id="关于try-catch-finally"><a href="#关于try-catch-finally" class="headerlink" title="关于try catch finally:"></a>关于try catch finally:</h5><p>当我们编写程序时，经常会遇到一些可能会引发异常的代码。为了处理这些异常情况，我们可以使用 try-catch-finally 结构来捕获和处理异常。下面是它的具体用法解释：</p><ol><li><strong>try</strong> 块：<ul><li>在 try 块中，我们编写可能会引发异常的代码。这些代码被放置在 try 块中，因为我们希望监视并处理可能发生的异常。</li></ul></li><li><strong>catch</strong> 块：<ul><li>如果在 try 块中的代码引发了异常，那么程序会跳转到 catch 块，并执行 catch 块中的代码。在 catch 块中，我们可以编写针对特定异常类型的处理逻辑，比如打印错误信息、记录日志或者采取其他恢复措施。</li></ul></li><li><strong>finally</strong> 块：<ul><li>无论是否发生异常，finally 块中的代码都会被执行。通常在 finally 块中放置一些清理工作，比如释放资源、关闭文件等操作。</li></ul></li></ol><p>综合起来，try-catch-finally 结构的作用是确保程序在遇到异常时能够进行适当的处理，同时保证一些必要的清理工作得以完成。</p><p>举例来说，比如在读取文件时可能会发生文件不存在的异常。我们可以将文件读取的代码放在 try 块中，然后在 catch 块中捕获文件不存在的异常并进行处理，最后在 finally 块中确保文件流得到关闭，以释放资源。这样可以保证程序在面对异常情况时仍能够安全运行，并且不会因为资源未释放而导致问题。</p>]]></content>
    
    
    
    <tags>
      
      <tag>wp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hgame week2 re wp</title>
    <link href="/2024/02/23/hgame%20week2%20re%20wp/"/>
    <url>/2024/02/23/hgame%20week2%20re%20wp/</url>
    
    <content type="html"><![CDATA[<h2 id="Arithmetic"><a href="#Arithmetic" class="headerlink" title="Arithmetic"></a>Arithmetic</h2><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402222130671.png" alt="image-20240222213004584"></p><p>[关于upx壳的一点认知，以及upx壳的特征识别 - 北北软件园 - 博客园 (cnblogs.com)](<a href="https://www.cnblogs.com/xiazai/p/14295684.html#:~:text=%E4%B8%80%E8%88%AC%E6%98%AF%E8%A2%AB%E8%AF%86%E5%88%AB%E5%87%BA%E4%BA%86upx%E7%9A%84%E7%89%B9%E5%BE%81%EF%BC%8C%E7%84%B6%E5%90%8E%E7%9B%B4%E6%8E%A5%E5%86%8D%E6%8B%96%E5%85%A5%E5%88%B0upx%E5%8A%A0%E5%A3%B3%E5%99%A8%E4%B8%AD%EF%BC%8C%E5%8A%A0%E5%A3%B3%E5%99%A8%E8%87%AA%E5%B7%B1%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%AF%86%E5%88%AB%E5%87%BA%E8%BF%99%E6%98%AF%E5%8A%A0%E8%BF%87%E5%A3%B3%E7%9A%84%EF%BC%8C%E7%84%B6%E5%90%8E%E6%89%A7%E8%A1%8C%E8%84%B1%E5%A3%B3%E3%80%82">https://www.cnblogs.com/xiazai/p/14295684.html#:~:text=一般是被识别出了upx的特征，然后直接再拖入到upx加壳器中，加壳器自己就可以识别出这是加过壳的，然后执行脱壳。</a> (upx加壳器就可以脱自己加密出来的upx) upx的特征，我们可以通过抹掉特征码来隐藏 特征码处1：upx字符串，特征码为55 50 58 一般存在于区段名称这里%2C等字节长度随意替换，对程序没有任何影响 特征码处2%3Aoep前几个字节,%3F%3F %3F%3F 00 8D BE %3F%3F %3F%3F %3F%3F)</p><p>upx特征码：55 50 58</p><p>首先，我们来讲一讲查壳的原理。不论是压缩壳，还是加密壳，都有特定的算法。加同种壳的不同应用程序，有一部分机器码是相同的，它们被称为“签名”或者“特征码”。有些壳还会将自身的一些信息写入可执行程序。</p><p><a href="https://blog.csdn.net/whatday/article/details/99709317?app_version=6.2.8&code=app_1562916241&csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%2299709317%22,%22source%22:%222301_79688961%22%7D&uLinkId=usr1mkqgl919blen&utm_source=app">手动去upx特征_upx -d-CSDN博客</a></p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402292002904.png" alt="image-20240229200154657"></p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402292002042.png" alt="image-20240229200230956"></p><p>对比，改成upx特征码</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402222220743.png" alt="image-20240222222044654"></p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402292003743.png" alt="image-20240229200320670"></p><p>然后保存文件，再次查壳发现文件由最开始的upx3.91+变成了upx3.96</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402222227317.png" alt="image-20240222222701283"></p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402222227288.png" alt="image-20240222222727256"></p><p>打开发现是这样的（部分）</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402272350601.png" alt="image-20240227235023536"></p><p>按照次规律下去，在最后一行第500行应该有500个数，只不过因为显示问题没用呈三角形排列</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402281332718.png" alt="image-20240228133245628"></p><p>点开查看dword_1400048B0,发现和1400048B4是连续的</p><p>所以可以判断得到路径：</p><p>若为1则加正下⽅的数，若为2则加右下⽅的数</p><p>v10为由⾸层加⾄末层的路径值的和 </p><p>路径和&gt;&#x3D;6752833的路径求md5即可得到路径</p><h5 id="exp"><a href="#exp" class="headerlink" title="exp:"></a>exp:</h5><p>#include &lt;bits&#x2F;stdc++.h&gt;<br>#include &lt;time.h&gt;<br>#define MAX 6752833</p><p>using namespace std;</p><p>long a[500][500], f[510][510], last[510][510], lis[510];<br>int path[510];</p><p>int main()<br>{<br>    srand(time(NULL));<br>    int x &#x3D; 1, y &#x3D; 1;<br>    FILE *fp &#x3D; fopen(“out”, “rb”);</p><pre><code class="hljs">while (fscanf(fp, &quot;%d&quot;, &amp;a[x][y]) != EOF)&#123;    if (x == y)//这个条件检查当前读取的位置是否位于数字金字塔的对角线上    &#123;        y = 1;//将 y 重置为 1，表示转到下一行的第一个位置        x++;//将 x 增加 1，表示转到下一行        continue;    &#125;    y++;//当数字金字塔的位置不在对角线上时，将 y 增加 1，表示继续读取当前行的下一个位置的数字&#125;x--;//在整个循环结束后，将 x 减去 1，因为在最后一次循环中，x 已经增加了一个额外的值，超过了实际的行数f[1][1] = a[1][1];for (int i = 2; i &lt;= x; i++)&#123;    for (int j = 1; j &lt;= i; j++)    &#123;        f[i][j] = f[i - 1][j] + a[i][j];        last[i][j] = j;        if (f[i - 1][j - 1] + a[i][j] &gt;= f[i][j])        &#123;            f[i][j] = f[i - 1][j - 1] + a[i][j];            last[i][j] = j - 1;        &#125;    &#125;&#125;//这部分代码使用动态规划的方法计算出从金字塔的顶部到每个位置的最大路径和。f[i][j] 表示从顶部到第 i 行第 j 列的最大路径和，last[i][j] 记录在计算最大路径和时选择的路径for (int i = 1; i &lt;= x; i++)&#123;    if (f[x][i] == 6752833)    &#123;        x = 500, y = i;        while (x &gt; 1)        &#123;            lis[x] = a[x][y];            if (last[x][y] == y - 1)            &#123;                path[x] = 2;                y = y - 1;            &#125;            else            &#123;                path[x] = 1;            &#125;            x--;        &#125;    &#125;&#125;for (int i = 2; i &lt;= 500; i++)&#123;    printf(&quot;%d&quot;, path[i]);&#125;return 0;</code></pre><p>}</p><p>hgame{934f7f68145038b3b81482b3d9f3a355}</p><h2 id="babyre"><a href="#babyre" class="headerlink" title="babyre"></a>babyre</h2><p>需要掌握：</p><p>1.ELF（Executable and Linkable Format）是一种常见的可执行文件和目标文件格式。在 ELF 文件中，有一个叫做 <strong>.init_array</strong> 的节（section），用于存放程序的初始化函数（init function）的地址。这些初始化函数会在程序执行之前被自动调用，用于执行一些必要的初始化工作。</p><p>.init_array 节中存放着一系列函数指针，这些函数指针指向程序中需要在加载时执行的初始化函数。操作系统在加载 ELF 文件时会依次调用这些初始化函数，确保程序的各个部分都得到正确的初始化。</p><p>需要注意的是，.init_array 节中的初始化函数的执行顺序是按照它们在节中的出现顺序来确定的。因此，开发者在编写这些初始化函数时需要考虑它们之间的依赖关系，以确保程序能够正确地初始化。</p><p>2.特定库&lt;pthread.h&gt;</p><p>​部分函数：</p><p><strong>sem_wait() 函数</strong>:</p><ul><li>当一个线程调用 sem_wait() 函数时，它会试图获取一个信号量。如果信号量的值大于 0，表示有可用的资源，那么该线程将继续执行，并且信号量的值会减 1。</li><li>如果信号量的值为 0，表示当前没有可用的资源，那么调用 sem_wait() 的线程会被挂起（阻塞），直到有其他线程调用 sem_post() 来增加信号量的值。</li></ul><p><strong>sem_post() 函数</strong>:</p><ul><li>当一个线程调用 sem_post() 函数时，它会释放一个资源，并将信号量的值加 1。</li><li>如果此时有其他线程正在等待该信号量（即信号量的值为 0），则会有一个或多个线程从 sem_wait() 中返回，并继续执行其后续操作。</li></ul><p>总的来说，信号量提供了一种线程间同步和互斥的机制，允许线程之间协调共享资源的访问。sem_wait() 用于等待资源的获取，并在获取到资源时继续执行，而在资源不可用时被挂起；sem_post() 用于释放资源，以便其他线程可以继续执行。这样，通过信号量的使用，可以有效地控制并发线程对共享资源的访问，避免竞态条件和数据不一致的问题。</p><h5 id="signal-8-handler-：这行代码用于设置信号处理函数。signal-函数用于注册信号处理函数，其中第一个参数表示信号编号，这里是-8（通常用于处理程序错误）。第二个参数是信号处理函数的地址，即-handler"><a href="#signal-8-handler-：这行代码用于设置信号处理函数。signal-函数用于注册信号处理函数，其中第一个参数表示信号编号，这里是-8（通常用于处理程序错误）。第二个参数是信号处理函数的地址，即-handler" class="headerlink" title="signal(8, handler) ：这行代码用于设置信号处理函数。signal 函数用于注册信号处理函数，其中第一个参数表示信号编号，这里是 8（通常用于处理程序错误）。第二个参数是信号处理函数的地址，即 handler"></a>signal(8, handler) ：这行代码用于设置信号处理函数。<code>signal</code> 函数用于注册信号处理函数，其中第一个参数表示信号编号，这里是 8（通常用于处理程序错误）。第二个参数是信号处理函数的地址，即 <code>handler</code></h5><p>使用：</p><ul><li><h6 id="sem-init-adress，0，初值-初始化信号值"><a href="#sem-init-adress，0，初值-初始化信号值" class="headerlink" title="sem_init(adress，0，初值)        初始化信号值"></a>sem_init(adress，0，初值)        初始化信号值</h6></li><li><h6 id="pthread-create-adress，0，函数，0-创建线程"><a href="#pthread-create-adress，0，函数，0-创建线程" class="headerlink" title="pthread_create(adress，0，函数，0)           创建线程"></a>pthread_create(adress，0，函数，0)           创建线程</h6></li><li><h6 id="sem-wait-adress-等待信号值，一旦信号值不为0，则信号值立马减一并返回，若信号值为0则阻塞线程的进行"><a href="#sem-wait-adress-等待信号值，一旦信号值不为0，则信号值立马减一并返回，若信号值为0则阻塞线程的进行" class="headerlink" title="sem_wait(adress)        等待信号值，一旦信号值不为0，则信号值立马减一并返回，若信号值为0则阻塞线程的进行"></a>sem_wait(adress)        等待信号值，一旦信号值不为0，则信号值立马减一并返回，若信号值为0则阻塞线程的进行</h6></li><li><h6 id="sem-post-adress-信号值加一"><a href="#sem-post-adress-信号值加一" class="headerlink" title="sem_post(adress)      信号值加一"></a>sem_post(adress)      信号值加一</h6></li><li><h6 id="pthread-join-ptr-0LL-暂停现行线程，直到指定线程运行完毕"><a href="#pthread-join-ptr-0LL-暂停现行线程，直到指定线程运行完毕" class="headerlink" title="pthread_join(*(&amp;ptr ), 0LL)   暂停现行线程，直到指定线程运行完毕"></a>pthread_join(*(&amp;ptr ), 0LL)   暂停现行线程，直到指定线程运行完毕</h6></li></ul><p>3.进程</p><p><a href="https://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html">进程与线程的一个简单解释 - 阮一峰的网络日志 (ruanyifeng.com)</a></p><p>4.浮点异常</p><ul><li>试图将一个数除以0</li><li>试图对负数取平方根</li><li>试图对负数取对数</li><li>浮点数溢出或下溢（例如，结果太大或太小无法表示）</li></ul><p>​在这种情况下，程序会收到一个 SIGFPE 信号并终止执行</p><p>做题：修改变量名后</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402232143280.png" alt="image-20240223214302243"></p><p>进入输入函数，可知 dword_41C0为输入input，点开后发现地址与4240连续，即输入32个字节，第33个字节被设置为249</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402232142518.png" alt="image-20240223214236445"></p><p>进入func1，如下</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402232150169.png" alt="image-20240223215051132"></p><p>用8.3 IDA远调 注意用同一个版本的server，不然就会报错</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402232211534.png" alt="image-20240223221128486"></p><p>调试</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402232326490.png" alt="image-20240223232657455"></p><p>调试到第四次，F8步过的时候，发生浮点异常</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402232328756.png" alt="image-20240223232802732"></p><p>对于<img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402232348608.png" alt="image-20240223234814579"></p><p>这段代码的作用是设置一个信号处理函数 <code>handler</code>，然后在执行关键代码之前，检查是否是第一次执行，如果是则注册信号处理函数，并进行数组元素异或操作。这样，在执行关键代码期间，如果产生了信号（例如，程序错误），会跳转到注册的信号处理函数进行相应的处理，所以最后得到字符串wtxfei</p><p>然后就是注意看清楚循环结构，一次循环会执行完1,2,3,4四个线程</p><h4 id="exp-1"><a href="#exp-1" class="headerlink" title="exp:"></a>exp:</h4><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402240150190.png" alt="image-20240224015018099"></p><p>hgame{you_are_3o_c1ever2_3Olve!}</p><h2 id="babyAndroid"><a href="#babyAndroid" class="headerlink" title="babyAndroid"></a>babyAndroid</h2><p>主要逻辑</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402241834999.png" alt="image-20240224183444916"></p><p>注意此时双击key获取的是key的资源id而不是key的值</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402241833507.png" alt="image-20240224183354420"></p><p>最初在下图中可得知经过加密后的数据如最下方check函数，发现是RC4加密</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402241820634.png" alt="image-20240224182056478"></p><p>接下来就是获取key（正确打开方式）</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">3e1fel<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402241556639.png"></p><p>使用工具解密，注意要将数据进行处理变为16进制，我们会发现得到的数据里面包含了负数</p><p>对于负数的转换，常用的方法是使用补码表示法。以下是将负数转换为十六进制的步骤：</p><ol><li>将负数的绝对值转换为二进制表示。例如，-75 的绝对值是 75，其二进制表示为 1001011。</li><li>如果二进制表示不足 8 位，需要在左侧填充零，使其达到 8 位长度。在这种情况下，补充前导零使二进制表示为 01001011。</li><li>取该二进制数的按位取反。对于 01001011，按位取反后为 10110100。</li><li>将按位取反后的二进制数加 1。对于 10110100，加 1 后为 10110101。</li><li>将得到的补码转换为十六进制表示。10110101 转换为十六进制表示为 0xB5。</li></ol><p>因此，-75 的十六进制表示为 0xB5。同样的方法可以应用于其他负数的转换。</p><p>按照以上方法，所以处理后得到的数据为 0xB5 0x50 0x50 0x30 0xA8 0x4B 0x67 0xD3 0xA5 0x59 0xC4 0x5B 0xCA 0x05 0x06 0xB8，去空格，替换小写后得 G&gt;IkH&lt;aHu5FE3GSV</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402241950194.png" alt="image-20240224195057092"></p><p>（不知道为什么拿cyberchef解出来不对）</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402241955465.png"></p><p>apk改后缀名为zip解压后在lib里面找到so文件，然后在native层</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402241629750.png" alt="image-20240224162921712"></p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402241753192.png" alt="image-20240224175313128"></p><p>点开函数发现是AES（可使用findcrypt判断）</p><p>得到加密数据</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402292005165.png" alt="image-20240229200503061"></p><p>（在汇编语言中，<code>DCB</code> 是 “Define Constant Byte” 的缩写，用于声明一个或多个字节常量。每个 <code>DCB</code> 指令后面跟随着一系列以逗号分隔的字节值。）</p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402251314330.png" alt="image-20240225131403217"></p><h2 id="ezcpp"><a href="#ezcpp" class="headerlink" title="ezcpp"></a>ezcpp</h2><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402242116472.png" alt="image-20240224211649383"></p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402242117762.png" alt="image-20240224211719667"></p><p><img src="https://cdn.jsdelivr.net/gh/pzlzx/tuchuang@main/main/202402242118370.png" alt="image-20240224211802299"></p><p>总的加密逻辑就这样，逆回去就行了（这个题因为数据是一样的但是我以为不一样，看wp看了半天最后知道是一样的……深深的伤透了我的心……）</p><p>循环四次，从后面往前面，八个字节为一组</p><h5 id="exp："><a href="#exp：" class="headerlink" title="exp："></a>exp：</h5><p>#include&lt;bits&#x2F;stdc++.h&gt;<br> using namespace std;<br> void decrypt(uint32_t* v, uint32_t* k)<br> {<br>   uint32_t v0 &#x3D; v[0], v1 &#x3D; v[1];<br>   uint32_t delta &#x3D; 0xdeadbeef, sum &#x3D; delta * 32;<br>   for (int i &#x3D; 0; i &lt; 32; i++)<br>   {<br>     v1 -&#x3D; (v0 + sum) ^ (k[2] + (v0 &lt;&lt; 4)) ^ (k[3] + (v0 &lt;&lt; 5));<br>     v0 -&#x3D; (v1 + sum) ^ (k[0] + (v1 &lt;&lt; 4)) ^ (k[1] + (v1 &lt;&lt;5));<br>     sum -&#x3D; delta;<br>   }<br>   v[0] &#x3D; v0, v[1] &#x3D; v1;<br> }</p><p> int main()<br> {<br>   uint32_t key[] &#x3D; {1234,2341,3412,4123};<br>   unsigned char cipher[] &#x3D; {0x88, 0x04, 0xC6, 0x6A, 0x7F, 0xA7, 0xEC, 0x27, 0x6E, 0xBF, 0xB8, 0xAA, 0x0D, 0x3A, 0xAD, 0xE7, 0x7E, 0x52, 0xFF, 0x8C, 0x8B, 0xEF, 0x11, 0x9C, 0x3D, 0xC3, 0xEA, 0xFD, 0x23, 0x1F, 0x71, 0x4D };<br>   decrypt((uint32_t *)&amp;cipher[24], key);<br>   decrypt((uint32_t *)&amp;cipher[16], key);<br>   decrypt((uint32_t *)&amp;cipher[8], key);<br>   decrypt((uint32_t *)&amp;cipher[0], key);<br>   printf(“%s”, cipher);</p><p> }</p><p>hgame</p>]]></content>
    
    
    
    <tags>
      
      <tag>wp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式（部分）</title>
    <link href="/2024/02/21/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E9%83%A8%E5%88%86%EF%BC%89/"/>
    <url>/2024/02/21/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E9%83%A8%E5%88%86%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="正则表达式（部分）"><a href="#正则表达式（部分）" class="headerlink" title="正则表达式（部分）"></a>正则表达式（部分）</h1><p>d? d出现0&#x2F;1次  </p><p>a＊ a可以出现0&#x2F;多次  </p><p>a+ a出现一次以上  </p><p>a｛6｝ a出现6次  </p><p>a｛2，｝ a出现2次以上  </p><p>a｛2，6｝ a出现2-6次  </p><h2 id="匹配多个字符："><a href="#匹配多个字符：" class="headerlink" title="匹配多个字符："></a>匹配多个字符：</h2><p>(ab)+ ab出现一次以上  </p><h2 id="或运算："><a href="#或运算：" class="headerlink" title="或运算："></a>或运算：</h2><p>a (cat|dog) 匹配 a cat or a dog  </p><p>a cat|dog 匹配 a cat or dog  </p><h2 id="字符类："><a href="#字符类：" class="headerlink" title="字符类："></a>字符类：</h2><p>匹配由abc构成的数据【abc】+ abc 出现一次以上 abc aabbcc  </p><p>【a-zA-Z0-9】 ABCabc123  </p><p>^ 排除 【^0-9】 匹配0-9之外的数据(包括换行符)  </p><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p>\d 数字字符 \d+ 匹配一个以上的数字  </p><p>\D 非数字字符  </p><p>\w 单词字符 单词 数字 下划线即英文字符  </p><p>\W 非单词字符  </p><p>\s 空白符 包含空格和换行符  </p><p>\S 非空白字符  </p><p>\b 单词的边界 单词的开头或结尾 单词与符号之前的边界  </p><p>\B 非单词的边界 符号与符号 单词与单词的边界  </p><p>. 任意字符不包含换行符  </p><p>\. 表示. 通过\进行了转义  </p><p>^ 匹配行首 $ 匹配行尾  </p><p>＊+｛｝贪婪匹配  </p><p>&lt;.+&gt; 会匹配整串 因为是贪婪匹配  </p><p>&lt;.+?&gt; 只匹配两个标签代码，➕? 设置为懒惰匹配</p>]]></content>
    
    
    
    <tags>
      
      <tag>tool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>zoomeye</title>
    <link href="/2024/02/19/zoomeye/"/>
    <url>/2024/02/19/zoomeye/</url>
    
    <content type="html"><![CDATA[<h1 id="zoomeye-md"><a href="#zoomeye-md" class="headerlink" title="zoomeye.md"></a>zoomeye.md</h1><p>应该最突出的就是首页的搜索引擎</p><p><a href="https://www.zoomeye.org/profile/domain">https://www.zoomeye.org/profile/domain</a></p><p>用处：可以查询域名&#x2F;IP关联信息，也可以查询子域名信息，并且支持TXT和Json 格式导出</p><h4 id="生活篇："><a href="#生活篇：" class="headerlink" title="生活篇："></a>生活篇：</h4><p>右上方个人的界面中，在数据订阅界面可以添加特定ip进行订阅，可以通过将自己的关注对象添加到订阅列表里面而避免查看众多网页。</p><p>ZoomEye可以记录的具体IP地址的变动：</p><p>例如：</p><ol><li><h5 id="IP地址更改：如果一个网站或服务的IP地址发生变化，ZoomEye可以记录这种变化。例如，当一个网站从一个服务器迁移到另一个服务器时，IP地址会发生变化，ZoomEye可以捕捉到这种变动。"><a href="#IP地址更改：如果一个网站或服务的IP地址发生变化，ZoomEye可以记录这种变化。例如，当一个网站从一个服务器迁移到另一个服务器时，IP地址会发生变化，ZoomEye可以捕捉到这种变动。" class="headerlink" title="IP地址更改：如果一个网站或服务的IP地址发生变化，ZoomEye可以记录这种变化。例如，当一个网站从一个服务器迁移到另一个服务器时，IP地址会发生变化，ZoomEye可以捕捉到这种变动。"></a>IP地址更改：如果一个网站或服务的IP地址发生变化，ZoomEye可以记录这种变化。例如，当一个网站从一个服务器迁移到另一个服务器时，IP地址会发生变化，ZoomEye可以捕捉到这种变动。</h5></li><li><h5 id="域名解析变化：如果一个域名的解析记录发生变化，导致与该域名相关联的IP地址发生变化，ZoomEye可以记录这种变化。这可能发生在网站迁移、域名所有权更改或DNS配置变动等情况下。"><a href="#域名解析变化：如果一个域名的解析记录发生变化，导致与该域名相关联的IP地址发生变化，ZoomEye可以记录这种变化。这可能发生在网站迁移、域名所有权更改或DNS配置变动等情况下。" class="headerlink" title="域名解析变化：如果一个域名的解析记录发生变化，导致与该域名相关联的IP地址发生变化，ZoomEye可以记录这种变化。这可能发生在网站迁移、域名所有权更改或DNS配置变动等情况下。"></a>域名解析变化：如果一个域名的解析记录发生变化，导致与该域名相关联的IP地址发生变化，ZoomEye可以记录这种变化。这可能发生在网站迁移、域名所有权更改或DNS配置变动等情况下。</h5></li><li><h5 id="IP地址切换：某些服务或网站可能会在不同的IP地址之间进行切换，以实现负载均衡或故障转移。ZoomEye可以记录这种IP地址切换的情况，当一个服务在不同的IP地址之间进行轮换时，ZoomEye可以捕捉到这种变动。"><a href="#IP地址切换：某些服务或网站可能会在不同的IP地址之间进行切换，以实现负载均衡或故障转移。ZoomEye可以记录这种IP地址切换的情况，当一个服务在不同的IP地址之间进行轮换时，ZoomEye可以捕捉到这种变动。" class="headerlink" title="IP地址切换：某些服务或网站可能会在不同的IP地址之间进行切换，以实现负载均衡或故障转移。ZoomEye可以记录这种IP地址切换的情况，当一个服务在不同的IP地址之间进行轮换时，ZoomEye可以捕捉到这种变动。"></a>IP地址切换：某些服务或网站可能会在不同的IP地址之间进行切换，以实现负载均衡或故障转移。ZoomEye可以记录这种IP地址切换的情况，当一个服务在不同的IP地址之间进行轮换时，ZoomEye可以捕捉到这种变动。</h5></li></ol><h5 id="针对以上功能，可以实现预防被网络诈骗，攻击等，例如一些网络技术人员通过改变ip地址来隐藏真实身份，或者通过改变ip地址隐藏行踪，传播违法内容等（具体的使用还可以结合对ip的精确地理定位）"><a href="#针对以上功能，可以实现预防被网络诈骗，攻击等，例如一些网络技术人员通过改变ip地址来隐藏真实身份，或者通过改变ip地址隐藏行踪，传播违法内容等（具体的使用还可以结合对ip的精确地理定位）" class="headerlink" title="针对以上功能，可以实现预防被网络诈骗，攻击等，例如一些网络技术人员通过改变ip地址来隐藏真实身份，或者通过改变ip地址隐藏行踪，传播违法内容等（具体的使用还可以结合对ip的精确地理定位）"></a>针对以上功能，可以实现预防被网络诈骗，攻击等，例如一些网络技术人员通过改变ip地址来隐藏真实身份，或者通过改变ip地址隐藏行踪，传播违法内容等（具体的使用还可以结合对ip的精确地理定位）</h5><p><a href="https://www.imagehub.cc/image/1hNr0a"><img src="https://s1.imagehub.cc/images/2024/02/19/1be02aae939aa9087ac7c3f4efd7eb51.png" alt="1be02aae939aa9087ac7c3f4efd7eb51.png"></a></p><p>曲线图可以直观显示订阅量变化</p><p><a href="https://www.imagehub.cc/image/1hNbXA"><img src="https://s1.imagehub.cc/images/2024/02/19/c5d64666abd174856df66e650d24303e.png" alt="c5d64666abd174856df66e650d24303e.png"></a></p><p>可以对ip所在地理位置进行解析应该zoomeye是除了搜索功能外的另外一个大的亮点，其位置可以精确到50m以内（只在中国大陆地区）</p><p><a href="https://www.imagehub.cc/image/1hNEdS"><img src="https://s1.imagehub.cc/images/2024/02/19/9f176a0d9672becf77818496cabaeef9.png" alt="9f176a0d9672becf77818496cabaeef9.png"></a></p><p>可以通过对特定端口的搜索来找到互联网上公开暴露该特定端口的服务，可以达到信息集合的效果</p><p>例如，搜索3306端口可以得到与MySOL数据库服务器相关的结果。</p><p><a href="https://www.imagehub.cc/image/1hNGWL"><img src="https://s1.imagehub.cc/images/2024/02/19/ae9e9798e358cdb76782a62c359d552d.png" alt="ae9e9798e358cdb76782a62c359d552d.png"></a></p><p>通过搜索可以得到正在运行3306端口上的MySQL数据库实例相关信息，例如主机名，IP地址，数据库版本以及使用MySOL数据库的应用程序或网站，即可以显示哪些IP地址正在使用MySQL数据库。<br>可以通过对搜索词的限制来缩小目标范围</p><p><a href="https://www.imagehub.cc/image/1hNPLB"><img src="https://s1.imagehub.cc/images/2024/02/19/d7fdc0f6d1e4563befe732073e41f77b.png" alt="d7fdc0f6d1e4563befe732073e41f77b.png"></a></p><p>通过点击ip可以获得该ip详情，也可以通过最下端查看相关漏洞</p><p><a href="https://www.imagehub.cc/image/1hNRqq"><img src="https://s1.imagehub.cc/images/2024/02/19/d1b0ba23f97d16a6a7c502a1ccca1ade.png" alt="d1b0ba23f97d16a6a7c502a1ccca1ade.png"></a></p><p><a href="https://www.imagehub.cc/image/1hNs3U"><img src="https://s1.imagehub.cc/images/2024/02/19/5407237573cc620928838dfb3aa7a7bb.png" alt="5407237573cc620928838dfb3aa7a7bb.png"></a></p><h4 id="企业篇"><a href="#企业篇" class="headerlink" title="企业篇"></a>企业篇</h4><p>可以针对ZoomEye-python命令行工具的API功能特性来实现：</p><p><a href="https://github.com/knownsec/ZoomEye-python">https://github.com/knownsec/ZoomEye-python</a></p><p>ZoomEye 记录所有主动发起网络攻击的IP记录，并且标记在IP信息中。可以提醒用户对目标进一步进行甄别，使得IP的标记更 加具备实用性，避免用户因盲目攻击目标从而给自身带来相关风险。</p><ol><li><h5 id="恶意活动检测：使用ZoomEye的自动化任务，可以定期搜索可疑IP地址、域名，URL等，通过将其与数据库中有关的恶意活动进行对比，最终可以实现自身对于恶意软件的预防。"><a href="#恶意活动检测：使用ZoomEye的自动化任务，可以定期搜索可疑IP地址、域名，URL等，通过将其与数据库中有关的恶意活动进行对比，最终可以实现自身对于恶意软件的预防。" class="headerlink" title="恶意活动检测：使用ZoomEye的自动化任务，可以定期搜索可疑IP地址、域名，URL等，通过将其与数据库中有关的恶意活动进行对比，最终可以实现自身对于恶意软件的预防。"></a>恶意活动检测：使用ZoomEye的自动化任务，可以定期搜索可疑IP地址、域名，URL等，通过将其与数据库中有关的恶意活动进行对比，最终可以实现自身对于恶意软件的预防。</h5><h5 id=""><a href="#" class="headerlink" title=""></a></h5></li></ol><p>例如在网络上浏览网页时，可能会有一些跳转链接，点击后可能会出现电脑提示不安全这种情况，此时如果想进一步了解相关的IP地址或域名的信息，可以使用ZoomEye的搜索功能，通过搜索IP地址或域名来获取更多的公开信息和资源。比如该IP地址或域名的历史记录、公开的漏洞信息、相关的网站或服务等。</p><pre><code class="hljs">（据了解好像原理主要是与数据库中里面已知的有关的恶意活动的ip地址黑名单进行比对，特征比对等，还不能完全借此直接判断一个ip的安全性）</code></pre><ol start="2"><li><h5 id="反向操作来健侧公开泄露的个人信息：利用ZoomEye搜索引擎，检索公开暴露的数据库和其他敏感信息，如社交媒体上的用户信息、电子邮件地址和密码。编写Python脚本，定期检查这些数据是否出现在公开泄露的数据源中，帮助企业及时发现泄露风险。"><a href="#反向操作来健侧公开泄露的个人信息：利用ZoomEye搜索引擎，检索公开暴露的数据库和其他敏感信息，如社交媒体上的用户信息、电子邮件地址和密码。编写Python脚本，定期检查这些数据是否出现在公开泄露的数据源中，帮助企业及时发现泄露风险。" class="headerlink" title="反向操作来健侧公开泄露的个人信息：利用ZoomEye搜索引擎，检索公开暴露的数据库和其他敏感信息，如社交媒体上的用户信息、电子邮件地址和密码。编写Python脚本，定期检查这些数据是否出现在公开泄露的数据源中，帮助企业及时发现泄露风险。"></a>反向操作来健侧公开泄露的个人信息：利用ZoomEye搜索引擎，检索公开暴露的数据库和其他敏感信息，如社交媒体上的用户信息、电子邮件地址和密码。编写Python脚本，定期检查这些数据是否出现在公开泄露的数据源中，帮助企业及时发现泄露风险。</h5></li></ol><p><a href="https://www.imagehub.cc/image/1hNHJ0"><img src="https://s1.imagehub.cc/images/2024/02/19/2693e6fd6e034429d4d38322fa9c8f39.png" alt="2693e6fd6e034429d4d38322fa9c8f39.png"></a></p><h4 id="使用体验："><a href="#使用体验：" class="headerlink" title="使用体验："></a>使用体验：</h4><h5 id="zoomeye网页设计很简洁，清晰明了，与其针对安全的核心功能相符合，可以很方便地搜索和获取关于互联网上的设备、服务和漏洞等信息。它提供了强大的功能和丰富的数据源"><a href="#zoomeye网页设计很简洁，清晰明了，与其针对安全的核心功能相符合，可以很方便地搜索和获取关于互联网上的设备、服务和漏洞等信息。它提供了强大的功能和丰富的数据源" class="headerlink" title="zoomeye网页设计很简洁，清晰明了，与其针对安全的核心功能相符合，可以很方便地搜索和获取关于互联网上的设备、服务和漏洞等信息。它提供了强大的功能和丰富的数据源"></a>zoomeye网页设计很简洁，清晰明了，与其针对安全的核心功能相符合，可以很方便地搜索和获取关于互联网上的设备、服务和漏洞等信息。它提供了强大的功能和丰富的数据源</h5><h4 id="建议："><a href="#建议：" class="headerlink" title="建议："></a>建议：</h4><h5 id="1-可以加强对数据库的丰富：虽然可见-Zoomeye-已经提供了大量的数据源，但仍然有些特定的目标无法覆盖，相信通过更多数据源的增加可以提供更全面和广泛的搜索结果"><a href="#1-可以加强对数据库的丰富：虽然可见-Zoomeye-已经提供了大量的数据源，但仍然有些特定的目标无法覆盖，相信通过更多数据源的增加可以提供更全面和广泛的搜索结果" class="headerlink" title="1.可以加强对数据库的丰富：虽然可见 Zoomeye 已经提供了大量的数据源，但仍然有些特定的目标无法覆盖，相信通过更多数据源的增加可以提供更全面和广泛的搜索结果"></a>1.可以加强对数据库的丰富：虽然可见 Zoomeye 已经提供了大量的数据源，但仍然有些特定的目标无法覆盖，相信通过更多数据源的增加可以提供更全面和广泛的搜索结果</h5><h5 id="2-完善使用说明：对于一些新用户或初次接触-Zoomeye-的人来说，整体的使用还是略显困难，通过完善平台自身介绍，如提供更多的文档、视频教程或在线指南，可以帮助用户更好地了解和使用这个平台，同时也可以达到扩展用户数的宣传的目的"><a href="#2-完善使用说明：对于一些新用户或初次接触-Zoomeye-的人来说，整体的使用还是略显困难，通过完善平台自身介绍，如提供更多的文档、视频教程或在线指南，可以帮助用户更好地了解和使用这个平台，同时也可以达到扩展用户数的宣传的目的" class="headerlink" title="2.完善使用说明：对于一些新用户或初次接触 Zoomeye 的人来说，整体的使用还是略显困难，通过完善平台自身介绍，如提供更多的文档、视频教程或在线指南，可以帮助用户更好地了解和使用这个平台，同时也可以达到扩展用户数的宣传的目的"></a>2.完善使用说明：对于一些新用户或初次接触 Zoomeye 的人来说，整体的使用还是略显困难，通过完善平台自身介绍，如提供更多的文档、视频教程或在线指南，可以帮助用户更好地了解和使用这个平台，同时也可以达到扩展用户数的宣传的目的</h5><h5 id="3-可以优化搜索引擎的语法"><a href="#3-可以优化搜索引擎的语法" class="headerlink" title="3.可以优化搜索引擎的语法"></a>3.可以优化搜索引擎的语法</h5><h5 id="4-在原有的文本搜索，ip搜索的基础上可以增加更多功能，例如将ip搜索与实景结合，增加图片识别功能等"><a href="#4-在原有的文本搜索，ip搜索的基础上可以增加更多功能，例如将ip搜索与实景结合，增加图片识别功能等" class="headerlink" title="4.在原有的文本搜索，ip搜索的基础上可以增加更多功能，例如将ip搜索与实景结合，增加图片识别功能等"></a>4.在原有的文本搜索，ip搜索的基础上可以增加更多功能，例如将ip搜索与实景结合，增加图片识别功能等</h5>]]></content>
    
    
    
    <tags>
      
      <tag>tool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cmake笔记</title>
    <link href="/2024/02/05/cmake%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/02/05/cmake%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="cmake"><a href="#cmake" class="headerlink" title="cmake"></a>cmake</h1><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>cmake的定义是什么 ？—–高级编译配置工具</p><p>当多个人用不同的语言或者编译器开发一个项目，最终要输出一个可执行文件或者共享库（dll，so等等）这时候神器就出现了—–CMake！</p><p>所有操作都是通过编译CMakeLists.txt来完成的—简单</p><p>官 方网站是 <a href="http://www.cmake.org/">www.cmake.org</a>，可以通过访问官方网站获得更多关于 cmake 的信息</p><p>学习CMake的目的，为将来处理大型的C&#x2F;C++&#x2F;JAVA项目做准备</p><h1 id="CMake安装"><a href="#CMake安装" class="headerlink" title="CMake安装"></a>CMake安装</h1><p>1、绝大多数的linux系统已经安装了CMake</p><p>2、Windows或某些没有安装过的linux系统，去<a href="http://www.cmake.org/HTML/Download.html">http://www.cmake.org/HTML/Download.htm</a>l  可以下载安装</p><h1 id="CMake一个HelloWord"><a href="#CMake一个HelloWord" class="headerlink" title="CMake一个HelloWord"></a>CMake一个HelloWord</h1><p>1、步骤一，写一个HelloWord</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#main.cpp</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>std::cout &lt;&lt;  <span class="hljs-string">&quot;hello word&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、步骤二，写CMakeLists.txt</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">#CMakeLists.<span class="hljs-function">txt</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">PROJECT</span> <span class="hljs-params">(HELLO)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">SET</span><span class="hljs-params">(SRC_LIST main.cpp)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">MESSAGE</span><span class="hljs-params">(STATUS <span class="hljs-string">&quot;This is BINARY dir &quot;</span> $&#123;HELLO_BINARY_DIR&#125;)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">MESSAGE</span><span class="hljs-params">(STATUS <span class="hljs-string">&quot;This is SOURCE dir &quot;</span>$&#123;HELLO_SOURCE_DIR&#125;)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">ADD_EXECUTABLE</span><span class="hljs-params">(hello $&#123;SRC_LIST&#125;)</span></span><br></code></pre></td></tr></table></figure><p>3、步骤三、使用cmake，生成makefile文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cmake .<br><br>输出：<br>[root@localhost cmake]<span class="hljs-meta"># cmake .</span><br><span class="hljs-function">CMake <span class="hljs-title">Warning</span> <span class="hljs-params">(dev)</span> in CMakeLists.txt:</span><br><span class="hljs-function">  Syntax Warning in cmake code at</span><br><span class="hljs-function"></span><br><span class="hljs-function">    /root/cmake/CMakeLists.txt:<span class="hljs-number">7</span>:<span class="hljs-number">37</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">  Argument not separated from preceding token by whitespace.</span><br><span class="hljs-function">This warning is for project developers.  Use -Wno-dev to suppress it.</span><br><span class="hljs-function"></span><br><span class="hljs-function">-- The C compiler identification is GNU <span class="hljs-number">10.2</span><span class="hljs-number">.1</span></span><br><span class="hljs-function">-- The CXX compiler identification is GNU <span class="hljs-number">10.2</span><span class="hljs-number">.1</span></span><br><span class="hljs-function">-- Check for working C compiler: /usr/bin/cc</span><br><span class="hljs-function">-- Check for working C compiler: /usr/bin/cc -- works</span><br><span class="hljs-function">-- Detecting C compiler ABI info</span><br><span class="hljs-function">-- Detecting C compiler ABI info - done</span><br><span class="hljs-function">-- Check for working CXX compiler: /usr/bin/c++</span><br><span class="hljs-function">-- Check for working CXX compiler: /usr/bin/c++ -- works</span><br><span class="hljs-function">-- Detecting CXX compiler ABI info</span><br><span class="hljs-function">-- Detecting CXX compiler ABI info - done</span><br><span class="hljs-function">-- This is BINARY dir /root/cmake</span><br><span class="hljs-function">-- This is SOURCE dir /root/cmake</span><br><span class="hljs-function">-- Configuring done</span><br><span class="hljs-function">-- Generating done</span><br><span class="hljs-function">-- Build files have been written to: /root/cmake</span><br></code></pre></td></tr></table></figure><p>目录下就生成了这些文件-CMakeFiles, CMakeCache.txt, cmake_install.cmake 等文件，并且生成了Makefile.<br>现在不需要理会这些文件的作用，以后你也可以不去理会。最关键的是，它自动生成了Makefile.</p><p>4、使用make命令编译</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">root@localhost cmake]<span class="hljs-meta"># make</span><br>Scanning dependencies of target hello<br>[<span class="hljs-number">100</span>%] Building CXX object CMakeFiles/hello.dir/main.cpp.o<br>Linking CXX executable hello<br>[<span class="hljs-number">100</span>%] Built target hello<br></code></pre></td></tr></table></figure><p>5、最终生成了Hello的可执行程序</p><h1 id="CMake一个HelloWord-的语法介绍"><a href="#CMake一个HelloWord-的语法介绍" class="headerlink" title="CMake一个HelloWord-的语法介绍"></a>CMake一个HelloWord-的语法介绍</h1><h2 id="PROJECT关键字"><a href="#PROJECT关键字" class="headerlink" title="PROJECT关键字"></a>PROJECT关键字</h2><p>可以用来指定工程的名字和支持的语言，默认支持所有语言</p><p>PROJECT (HELLO)   指定了工程的名字，并且支持所有语言—建议</p><p>PROJECT (HELLO CXX)      指定了工程的名字，并且支持语言是C++</p><p>PROJECT (HELLO C CXX)      指定了工程的名字，并且支持语言是C和C++</p><p>该指定隐式定义了两个CMAKE的变量</p><p><projectname>_BINARY_DIR，本例中是 HELLO_BINARY_DIR</p><p><projectname>_SOURCE_DIR，本例中是 HELLO_SOURCE_DIR</p><p>MESSAGE关键字就可以直接使用者两个变量，当前都指向当前的工作目录，后面会讲外部编译</p><p>问题：如果改了工程名，这两个变量名也会改变</p><p>解决：又定义两个预定义变量：PROJECT_BINARY_DIR和PROJECT_SOURCE_DIR，这两个变量和HELLO_BINARY_DIR，HELLO_SOURCE_DIR是一致的。所以改了工程名也没有关系</p><h2 id="SET关键字"><a href="#SET关键字" class="headerlink" title="SET关键字"></a>SET关键字</h2><p>用来显示的指定变量的</p><p>SET(SRC_LIST main.cpp)    SRC_LIST变量就包含了main.cpp</p><p>也可以 SET(SRC_LIST main.cpp t1.cpp t2.cpp)</p><h2 id="MESSAGE关键字"><a href="#MESSAGE关键字" class="headerlink" title="MESSAGE关键字"></a>MESSAGE关键字</h2><p>向终端输出用户自定义的信息</p><p>主要包含三种信息：</p><ul><li>SEND_ERROR，产生错误，生成过程被跳过。</li><li>SATUS，输出前缀为—的信息。</li><li>FATAL_ERROR，立即终止所有 cmake 过程.</li></ul><h2 id="ADD-EXECUTABLE关键字"><a href="#ADD-EXECUTABLE关键字" class="headerlink" title="ADD_EXECUTABLE关键字"></a>ADD_EXECUTABLE关键字</h2><p>生成可执行文件</p><p>ADD_EXECUTABLE(hello ${SRC_LIST})     生成的可执行文件名是hello，源文件读取变量SRC_LIST中的内容</p><p>也可以直接写 ADD_EXECUTABLE(hello main.cpp)</p><p>上述例子可以简化的写成</p><p>PROJECT(HELLO)<br>ADD_EXECUTABLE(hello main.cpp)</p><p>注意：工程名的 HELLO 和生成的可执行文件 hello 是没有任何关系的</p><h1 id="语法的基本原则"><a href="#语法的基本原则" class="headerlink" title="语法的基本原则"></a>语法的基本原则</h1><ul><li><p>变量使用${}方式取值，但是在 IF 控制语句中是直接使用变量名</p></li><li><p>指令(参数 1 参数 2…) 参数使用括弧括起，参数之间使用空格或分号分开。 以上面的 ADD_EXECUTABLE 指令为例，如果存在另外一个 func.cpp 源文件<br>  就要写成：ADD_EXECUTABLE(hello main.cpp func.cpp)或者ADD_EXECUTABLE(hello main.cpp;func.cpp)</p></li><li><p>指令是大小写无关的，参数和变量是大小写相关的。但，推荐你全部使用大写指令</p></li></ul><h2 id="语法注意事项"><a href="#语法注意事项" class="headerlink" title="语法注意事项"></a>语法注意事项</h2><ul><li>SET(SRC_LIST main.cpp) 可以写成 SET(SRC_LIST “main.cpp”)，如果源文件名中含有空格，就必须要加双引号</li><li>ADD_EXECUTABLE(hello main) 后缀可以不行，他会自动去找.c和.cpp，最好不要这样写，可能会有这两个文件main.cpp和main</li></ul><h1 id="内部构建和外部构建"><a href="#内部构建和外部构建" class="headerlink" title="内部构建和外部构建"></a>内部构建和外部构建</h1><ul><li>上述例子就是内部构建，他生产的临时文件特别多，不方便清理</li><li>外部构建，就会把生成的临时文件放在build目录下，不会对源文件有任何影响强烈使用外部构建方式</li></ul><h2 id="外部构建方式举例"><a href="#外部构建方式举例" class="headerlink" title="外部构建方式举例"></a>外部构建方式举例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//例子目录，CMakeLists.txt和上面例子一致</span><br>[root@localhost cmake]<span class="hljs-meta"># pwd</span><br>/root/cmake<br>[root@localhost cmake]<span class="hljs-meta"># ll</span><br>total <span class="hljs-number">8</span><br>-rw-r--r--. <span class="hljs-number">1</span> root root <span class="hljs-number">198</span> Dec <span class="hljs-number">28</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span> CMakeLists.txt<br>-rw-r--r--. <span class="hljs-number">1</span> root root  <span class="hljs-number">76</span> Dec <span class="hljs-number">28</span> <span class="hljs-number">00</span>:<span class="hljs-number">18</span> main.cpp<br></code></pre></td></tr></table></figure><p>1、建立一个build目录，可以在任何地方，建议在当前目录下</p><p>2、进入build，运行cmake ..    当然..表示上一级目录，你可以写CMakeLists.txt所在的绝对路径，生产的文件都在build目录下了</p><p>3、在build目录下，运行make来构建工程</p><p>注意外部构建的两个变量</p><p>1、HELLO_SOURCE_DIR  还是工程路径</p><p>2、HELLO_BINARY_DIR   编译路径 也就是 &#x2F;root&#x2F;cmake&#x2F;bulid</p><h1 id="让Hello-World看起来更像一个工程"><a href="#让Hello-World看起来更像一个工程" class="headerlink" title="让Hello World看起来更像一个工程"></a>让Hello World看起来更像一个工程</h1><ul><li>为工程添加一个子目录 src，用来放置工程源代码</li><li>添加一个子目录 doc，用来放置这个工程的文档 hello.txt</li><li>在工程目录添加文本文件 COPYRIGHT, README</li><li>在工程目录添加一个 <a href="http://runhello.sh/">runhello.sh</a> 脚本，用来调用 hello 二进制</li><li>将构建后的目标文件放入构建目录的 bin 子目录</li><li>将 doc 目录 的内容以及 COPYRIGHT&#x2F;README 安装到&#x2F;usr&#x2F;share&#x2F;doc&#x2F;cmake&#x2F;</li></ul><h2 id="将目标文件放入构建目录的-bin-子目录"><a href="#将目标文件放入构建目录的-bin-子目录" class="headerlink" title="将目标文件放入构建目录的 bin 子目录"></a>将目标文件放入构建目录的 bin 子目录</h2><p>每个目录下都要有一个CMakeLists.txt说明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[root@localhost cmake]<span class="hljs-meta"># tree</span><br>.<br>├── build<br>├── CMakeLists.txt<br>└── src<br>    ├── CMakeLists.txt<br>    └── main.cpp<br></code></pre></td></tr></table></figure><p>外层CMakeLists.txt</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">PROJECT</span>(HELLO)<br><span class="hljs-built_in">ADD_SUBDIRECTORY</span>(src bin)<br></code></pre></td></tr></table></figure><p>src下的CMakeLists.txt</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">ADD_EXECUTABLE</span>(hello main.cpp)<br></code></pre></td></tr></table></figure><h3 id="ADD-SUBDIRECTORY-指令"><a href="#ADD-SUBDIRECTORY-指令" class="headerlink" title="ADD_SUBDIRECTORY 指令"></a>ADD_SUBDIRECTORY 指令</h3><p>ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</p><ul><li><p>这个指令用于向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置</p></li><li><p>EXCLUDE_FROM_ALL函数是将写的目录从编译中排除，如程序中的example</p></li><li><p>ADD_SUBDIRECTORY(src bin)<br>  将 src 子目录加入工程并指定编译输出(包含编译中间结果)路径为bin 目录<br>  如果不进行 bin 目录的指定，那么编译结果(包括中间结果)都将存放在build&#x2F;src 目录</p></li></ul><h3 id="更改二进制的保存路径"><a href="#更改二进制的保存路径" class="headerlink" title="更改二进制的保存路径"></a>更改二进制的保存路径</h3><p>SET 指令重新定义 EXECUTABLE_OUTPUT_PATH 和 LIBRARY_OUTPUT_PATH 变量 来指定最终的目标二进制的位置</p><p>SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}&#x2F;bin)<br>SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}&#x2F;lib)</p><p>思考：加载哪个CMakeLists.txt当中</p><p>哪里要改变目标存放路径，就在哪里加入上述的定义，所以应该在src下的CMakeLists.txt下写</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ul><li>一种是从代码编译后直接 make install 安装</li><li>一种是打包时的指定 目录安装。<ul><li>简单的可以这样指定目录：make install DESTDIR&#x3D;&#x2F;tmp&#x2F;test</li><li>稍微复杂一点可以这样指定目录：.&#x2F;configure –prefix&#x3D;&#x2F;usr</li></ul></li></ul><h2 id="如何安装HelloWord"><a href="#如何安装HelloWord" class="headerlink" title="如何安装HelloWord"></a>如何安装HelloWord</h2><p>使用CMAKE一个新的指令：INSTALL</p><p>INSTALL的安装可以包括：二进制、动态库、静态库以及文件、目录、脚本等</p><p>使用CMAKE一个新的变量：CMAKE_INSTALL_PREFIX</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 目录树结构</span><br>[root@localhost cmake]<span class="hljs-meta"># tree</span><br>.<br>├── build<br>├── CMakeLists.txt<br>├── COPYRIGHT<br>├── doc<br>│   └── hello.txt<br>├── README<br>├── runhello.sh<br>└── src<br>    ├── CMakeLists.txt<br>    └── main.cpp<br><br><span class="hljs-number">3</span> directories, <span class="hljs-number">7</span> files<br></code></pre></td></tr></table></figure><h3 id="安装文件COPYRIGHT和README"><a href="#安装文件COPYRIGHT和README" class="headerlink" title="安装文件COPYRIGHT和README"></a>安装文件COPYRIGHT和README</h3><p>INSTALL(FILES COPYRIGHT README DESTINATION share&#x2F;doc&#x2F;cmake&#x2F;)</p><p>FILES：文件</p><p>DESTINATION：</p><p>1、写绝对路径</p><p>2、可以写相对路径，相对路径实际路径是：${CMAKE_INSTALL_PREFIX}&#x2F;&lt;DESTINATION 定义的路径&gt;</p><p>CMAKE_INSTALL_PREFIX  默认是在 &#x2F;usr&#x2F;local&#x2F;</p><p>cmake -DCMAKE_INSTALL_PREFIX&#x3D;&#x2F;usr    在cmake的时候指定CMAKE_INSTALL_PREFIX变量的路径</p><h3 id="安装脚本runhello-sh"><a href="#安装脚本runhello-sh" class="headerlink" title="安装脚本runhello.sh"></a>安装脚本runhello.sh</h3><p>PROGRAMS：非目标文件的可执行程序安装(比如脚本之类)</p><p>INSTALL(PROGRAMS runhello.sh DESTINATION bin)</p><p>说明：实际安装到的是 &#x2F;usr&#x2F;bin</p><h3 id="安装-doc-中的-hello-txt"><a href="#安装-doc-中的-hello-txt" class="headerlink" title="安装 doc 中的 hello.txt"></a>安装 doc 中的 hello.txt</h3><ul><li><p>一、是通过在 doc 目录建立CMakeLists.txt ，通过install下的file</p></li><li><p>二、是直接在工程目录通过<br>   INSTALL(DIRECTORY doc&#x2F; DESTINATION share&#x2F;doc&#x2F;cmake)</p></li></ul><p>DIRECTORY 后面连接的是所在 Source 目录的相对路径</p><p>注意：abc 和 abc&#x2F;有很大的区别</p><p>目录名不以&#x2F;结尾：这个目录将被安装为目标路径下的</p><p>目录名以&#x2F;结尾：将这个目录中的内容安装到目标路径</p><h3 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h3><p>cmake ..</p><p>make</p><p>make install</p><h1 id="静态库和动态库的构建"><a href="#静态库和动态库的构建" class="headerlink" title="静态库和动态库的构建"></a>静态库和动态库的构建</h1><p>任务：</p><p>１，建立一个静态库和动态库，提供 HelloFunc 函数供其他程序编程使用，HelloFunc 向终端输出 Hello World 字符串。 </p><p>２，安装头文件与共享库。</p><p>静态库和动态库的区别</p><ul><li>静态库的扩展名一般为“.a”或“.lib”；动态库的扩展名一般为“.so”或“.dll”。</li><li>静态库在编译时会直接整合到目标程序中，编译成功的可执行文件可独立运行</li><li>动态库在编译时不会放到连接的目标程序中，即可执行文件无法单独运行。</li></ul><h2 id="构建实例"><a href="#构建实例" class="headerlink" title="构建实例"></a>构建实例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[root@localhost cmake2]<span class="hljs-meta"># tree</span><br>.<br>├── build<br>├── CMakeLists.txt<br>└── lib<br>    ├── CMakeLists.txt<br>    ├── hello.cpp<br>    └── hello.h<br></code></pre></td></tr></table></figure><p>hello.h中的内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> HELLO_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Hello_H</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HelloFunc</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>hello.cpp中的内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hello.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HelloFunc</span><span class="hljs-params">()</span></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Hello World&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>项目中的cmake内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">PROJECT</span>(HELLO)<br><span class="hljs-built_in">ADD_SUBDIRECTORY</span>(lib bin)<br></code></pre></td></tr></table></figure><p>lib中CMakeLists.txt中的内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">SET</span>(LIBHELLO_SRC hello.cpp)<br><span class="hljs-built_in">ADD_LIBRARY</span>(hello SHARED $&#123;LIBHELLO_SRC&#125;)<br></code></pre></td></tr></table></figure><h3 id="ADD-LIBRARY"><a href="#ADD-LIBRARY" class="headerlink" title="ADD_LIBRARY"></a>ADD_LIBRARY</h3><p>ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})</p><ul><li>hello：就是正常的库名，生成的名字前面会加上lib，最终产生的文件是libhello.so</li><li>SHARED，动态库    STATIC，静态库</li><li>${LIBHELLO_SRC} ：源文件</li></ul><h3 id="同时构建静态和动态库"><a href="#同时构建静态和动态库" class="headerlink" title="同时构建静态和动态库"></a>同时构建静态和动态库</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 如果用这种方式，只会构建一个动态库，不会构建出静态库，虽然静态库的后缀是.a</span><br><span class="hljs-built_in">ADD_LIBRARY</span>(hello SHARED $&#123;LIBHELLO_SRC&#125;)<br><span class="hljs-built_in">ADD_LIBRARY</span>(hello STATIC $&#123;LIBHELLO_SRC&#125;)<br><br><span class="hljs-comment">// 修改静态库的名字，这样是可以的，但是我们往往希望他们的名字是相同的，只是后缀不同而已</span><br><span class="hljs-built_in">ADD_LIBRARY</span>(hello SHARED $&#123;LIBHELLO_SRC&#125;)<br><span class="hljs-built_in">ADD_LIBRARY</span>(hello_static STATIC $&#123;LIBHELLO_SRC&#125;)<br></code></pre></td></tr></table></figure><h3 id="SET-TARGET-PROPERTIES"><a href="#SET-TARGET-PROPERTIES" class="headerlink" title="SET_TARGET_PROPERTIES"></a>SET_TARGET_PROPERTIES</h3><p>这条指令可以用来设置输出的名称，对于动态库，还可以用来指定动态库版本和 API 版本</p><p>同时构建静态和动态库</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">SET</span>(LIBHELLO_SRC hello.cpp)<br><br><span class="hljs-built_in">ADD_LIBRARY</span>(hello_static STATIC $&#123;LIBHELLO_SRC&#125;)<br><br><span class="hljs-comment">//对hello_static的重名为hello</span><br><span class="hljs-built_in">SET_TARGET_PROPERTIES</span>(hello_static PROPERTIES  OUTPUT_NAME <span class="hljs-string">&quot;hello&quot;</span>)<br><span class="hljs-comment">//cmake 在构建一个新的target 时，会尝试清理掉其他使用这个名字的库，因为，在构建 libhello.so 时， 就会清理掉 libhello.a</span><br><span class="hljs-built_in">SET_TARGET_PROPERTIES</span>(hello_static PROPERTIES CLEAN_DIRECT_OUTPUT <span class="hljs-number">1</span>)<br><br><span class="hljs-built_in">ADD_LIBRARY</span>(hello SHARED $&#123;LIBHELLO_SRC&#125;)<br><br><span class="hljs-built_in">SET_TARGET_PROPERTIES</span>(hello PROPERTIES  OUTPUT_NAME <span class="hljs-string">&quot;hello&quot;</span>)<br><span class="hljs-built_in">SET_TARGET_PROPERTIES</span>(hello PROPERTIES CLEAN_DIRECT_OUTPUT <span class="hljs-number">1</span>)<br><br></code></pre></td></tr></table></figure><h3 id="动态库的版本号"><a href="#动态库的版本号" class="headerlink" title="动态库的版本号"></a>动态库的版本号</h3><p>一般动态库都有一个版本号的关联</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">libhello.so<span class="hljs-number">.1</span><span class="hljs-number">.2</span><br>libhello.so -&gt;libhello.so<span class="hljs-number">.1</span><br>libhello.so<span class="hljs-number">.1</span>-&gt;libhello.so<span class="hljs-number">.1</span><span class="hljs-number">.2</span><br></code></pre></td></tr></table></figure><p>CMakeLists.txt 插入如下</p><p><code>SET_TARGET_PROPERTIES(hello PROPERTIES VERSION 1.2 SOVERSION 1)</code></p><p>VERSION 指代动态库版本，SOVERSION 指代 API 版本。</p><h3 id="安装共享库和头文件"><a href="#安装共享库和头文件" class="headerlink" title="安装共享库和头文件"></a>安装共享库和头文件</h3><p>本例中我们将 hello 的共享库安装到<prefix>&#x2F;lib目录，</p><p>将 hello.h 安装到<prefix>&#x2F;include&#x2F;hello 目录</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//文件放到该目录下</span><br><span class="hljs-built_in">INSTALL</span>(FILES hello.h DESTINATION include/hello)<br><br><span class="hljs-comment">//二进制，静态库，动态库安装都用TARGETS</span><br><span class="hljs-comment">//ARCHIVE 特指静态库，LIBRARY 特指动态库，RUNTIME 特指可执行目标二进制。</span><br><span class="hljs-built_in">INSTALL</span>(TARGETS hello hello_static LIBRARY DESTINATION lib ARCHIVE DESTINATION lib)<br></code></pre></td></tr></table></figure><p>注意：</p><p>安装的时候，指定一下路径，放到系统下</p><p><code>cmake -DCMAKE_INSTALL_PREFIX=/usr ..</code></p><h3 id="使用外部共享库和头文件"><a href="#使用外部共享库和头文件" class="headerlink" title="使用外部共享库和头文件"></a>使用外部共享库和头文件</h3><p>准备工作，新建一个目录来使用外部共享库和头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[root@MiWiFi-R4CM-srv cmake3]<span class="hljs-meta"># tree</span><br>.<br>├── build<br>├── CMakeLists.txt<br>└── src<br>    ├── CMakeLists.txt<br>    └── main.cpp<br></code></pre></td></tr></table></figure><p>main.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hello.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">HelloFunc</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解决：make后头文件找不到的问题"><a href="#解决：make后头文件找不到的问题" class="headerlink" title="解决：make后头文件找不到的问题"></a>解决：make后头文件找不到的问题</h3><p>PS：include &lt;hello&#x2F;hello.h&gt;  这样include是可以，这么做的话，就没啥好讲的了</p><p>关键字：INCLUDE_DIRECTORIES    这条指令可以用来向工程添加多个特定的头文件搜索路径，路径之间用空格分割</p><p>在CMakeLists.txt中加入头文件搜索路径</p><p>INCLUDE_DIRECTORIES(&#x2F;usr&#x2F;include&#x2F;hello)</p><p>感谢：</p><p>网友：zcc720的提醒</p><h3 id="解决：找到引用的函数问题"><a href="#解决：找到引用的函数问题" class="headerlink" title="解决：找到引用的函数问题"></a>解决：找到引用的函数问题</h3><p>报错信息：undefined reference to &#96;HelloFunc()’</p><p>关键字：LINK_DIRECTORIES     添加非标准的共享库搜索路径</p><p>指定第三方库所在路径，LINK_DIRECTORIES(&#x2F;home&#x2F;myproject&#x2F;libs)</p><p>关键字：TARGET_LINK_LIBRARIES    添加需要链接的共享库</p><p>TARGET_LINK_LIBRARIES的时候，只需要给出动态链接库的名字就行了。</p><p>在CMakeLists.txt中插入链接共享库，主要要插在executable的后面</p><p>查看main的链接情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[root@MiWiFi-R4CM-srv bin]<span class="hljs-meta"># ldd main </span><br>    linux-vdso.so<span class="hljs-number">.1</span> =&gt;  (<span class="hljs-number">0x00007ffedfda4000</span>)<br>    libhello.so =&gt; /lib64/libhello.<span class="hljs-built_in">so</span> (<span class="hljs-number">0x00007f41c0d8f000</span>)<br>    libstdc++.so<span class="hljs-number">.6</span> =&gt; /lib64/libstdc++.so<span class="hljs-number">.6</span> (<span class="hljs-number">0x00007f41c0874000</span>)<br>    libm.so<span class="hljs-number">.6</span> =&gt; /lib64/libm.so<span class="hljs-number">.6</span> (<span class="hljs-number">0x00007f41c0572000</span>)<br>    libgcc_s.so<span class="hljs-number">.1</span> =&gt; /lib64/libgcc_s.so<span class="hljs-number">.1</span> (<span class="hljs-number">0x00007f41c035c000</span>)<br>    libc.so<span class="hljs-number">.6</span> =&gt; /lib64/libc.so<span class="hljs-number">.6</span> (<span class="hljs-number">0x00007f41bff8e000</span>)<br>    /lib64/ld-linux-x86<span class="hljs-number">-64.</span>so<span class="hljs-number">.2</span> (<span class="hljs-number">0x00007f41c0b7c000</span>)<br></code></pre></td></tr></table></figure><p>链接静态库</p><p><code>TARGET_LINK_LIBRARIES(main libhello.a)</code></p><h3 id="特殊的环境变量-CMAKE-INCLUDE-PATH-和-CMAKE-LIBRARY-PATH"><a href="#特殊的环境变量-CMAKE-INCLUDE-PATH-和-CMAKE-LIBRARY-PATH" class="headerlink" title="特殊的环境变量 CMAKE_INCLUDE_PATH 和 CMAKE_LIBRARY_PATH"></a>特殊的环境变量 CMAKE_INCLUDE_PATH 和 CMAKE_LIBRARY_PATH</h3><p>注意：这两个是环境变量而不是 cmake 变量，可以在linux的bash中进行设置</p><p>我们上面例子中使用了绝对路径INCLUDE_DIRECTORIES(&#x2F;usr&#x2F;include&#x2F;hello)来指明include路径的位置</p><p>我们还可以使用另外一种方式，使用环境变量export CMAKE_INCLUDE_PATH&#x3D;&#x2F;usr&#x2F;include&#x2F;hello</p><p>补充：生产debug版本的方法：<br>cmake .. -DCMAKE_BUILD_TYPE&#x3D;debug</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
    
    <tags>
      
      <tag>tool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>极客wp</title>
    <link href="/2023/12/18/%E6%9E%81%E5%AE%A2wp-1/"/>
    <url>/2023/12/18/%E6%9E%81%E5%AE%A2wp-1/</url>
    
    <content type="html"><![CDATA[<h1 id="极客wp"><a href="#极客wp" class="headerlink" title="极客wp"></a>极客wp</h1><h4 id="点击就送的逆向题"><a href="#点击就送的逆向题" class="headerlink" title="点击就送的逆向题"></a>点击就送的逆向题</h4><p>发现文件后缀名是.s</p><p>gcc命令其实依次执行了四步操作：</p><p>1.预处理(Preprocessing)</p><p>2.编译(Compilation),</p><p>3.汇编(Assemble),</p><p>4.链接(Linking)。</p><p><a href="https://zhuanlan.zhihu.com/p/111500914">GCC编译过程（预处理-&gt;编译-&gt;汇编-&gt;链接） - 知乎 (zhihu.com)</a></p><p>通过上述内容发现还需要先将汇编代码.s变成机器码.o，生成目标文件</p><p>在虚拟机里面进行</p><p><a href="https://www.imagehub.cc/image/1xzw0z"><img src="https://s1.imagehub.cc/images/2023/11/27/a2d5158a58c6d18755b59e46bbe6103a.png" alt="a2d5158a58c6d18755b59e46bbe6103a.png"></a></p><p>然后把得到的目标文件拖64IDA里面，观察逻辑发现处理后得到的s1和s2相等，再推回去即可</p><p><a href="https://www.imagehub.cc/image/1xze8j"><img src="https://s1.imagehub.cc/images/2023/11/27/90d0a9715d3dcdee04498c8f5d208a9c.png" alt="90d0a9715d3dcdee04498c8f5d208a9c.png"></a></p><p><a href="https://www.imagehub.cc/image/1xz6PR"><img src="https://s1.imagehub.cc/images/2023/11/27/9b657dac96012ce3b07e77690e1c8cb3.png" alt="9b657dac96012ce3b07e77690e1c8cb3.png"></a></p><h4 id="幸运数字"><a href="#幸运数字" class="headerlink" title="幸运数字"></a>幸运数字</h4><p>拖进DIE发现是PE64，搞64位IDA里面去</p><p><a href="https://www.imagehub.cc/image/1xmtHv"><img src="https://s1.imagehub.cc/images/2023/11/27/a74a56791c4338fff2860ffa5d5752db.md.png" alt="a74a56791c4338fff2860ffa5d5752db.md.png"></a></p><p><a href="https://www.imagehub.cc/image/1xmxot"><img src="https://s1.imagehub.cc/images/2023/11/27/8bc3d63e470aeb29d7976619d0623346.png" alt="8bc3d63e470aeb29d7976619d0623346.png"></a></p><p>由上面二图可知，对&amp;Format,&amp;Buffer,&amp;byte_40401C点进去a一下得下图，cmp_data存的是ascii，所以注意46行存储数据的处理，转换成对应的ascii，这个地方刚好只存了5个字符到数组中，得到对应的数据为111, 57, 54, 42, 35</p><p><a href="https://www.imagehub.cc/image/1xmEbS"><img src="https://s1.imagehub.cc/images/2023/11/27/76bf846c9319db536c7d48e43060a9aa.png" alt="76bf846c9319db536c7d48e43060a9aa.png"></a></p><p><a href="https://www.imagehub.cc/image/1xmGEL"><img src="https://s1.imagehub.cc/images/2023/11/27/cc3329e3d5dcaaac28b90f185d59a2ab.md.png" alt="cc3329e3d5dcaaac28b90f185d59a2ab.md.png"  /></a></p><p>对v5进行处理，发现是个递归，k在0-999，则取k&#x3D;0，此时返回值为result(-1)+0;取不到result(-1)，因为k为unsigned，</p><p>所以k&#x3D;0时返回值为0；</p><p>取k&#x3D;1，返回值为1</p><p>取k&#x3D;2，返回值为1+2</p><p>…………</p><p>故v5 &#x3D; (1+k)*k&#x2F;2</p><p><a href="https://www.imagehub.cc/image/1xmPvB"><img src="https://s1.imagehub.cc/images/2023/11/27/587e59f04c3844ae08f84141af5a07e2.png" alt="587e59f04c3844ae08f84141af5a07e2.png"></a></p><p>取余记得用 int 取整</p><p>防止数据超出ascii码表值，所以&amp;0xFF,取低八位或者直接%256</p><p><a href="https://www.imagehub.cc/image/1xmRSq"><img src="https://s1.imagehub.cc/images/2023/11/27/1b6cbeb5cb83824acd5b16c483c5bfdc.md.png" alt="1b6cbeb5cb83824acd5b16c483c5bfdc.md.png"></a></p><p>最后记得对输出的字符串进行筛选……</p><h4 id="shiftjmp"><a href="#shiftjmp" class="headerlink" title="shiftjmp"></a>shiftjmp</h4><p><a href="https://imgse.com/i/piBJS1O"><img src="https://z1.ax1x.com/2023/11/27/piBJS1O.md.png" alt="piBJS1O.md.png"></a></p><p>进到main函数里面以后发现无法生成反汇编代码</p><p>汇编跳转指令有问题</p><p>因为jz前为rax和rax的异或 值为0</p><p>所以执行jz后的指令 跳转到 loc_117A+1，为117B</p><p>发现中间地址被折叠了</p><p>所以对着117A地址D一下，得到下图</p><p><a href="https://imgse.com/i/piBJPnH"><img src="https://z1.ax1x.com/2023/11/27/piBJPnH.md.png" alt="piBJPnH.md.png"></a></p><p><a href="https://imgse.com/i/piBJV4P"><img src="https://z1.ax1x.com/2023/11/27/piBJV4P.png" alt="piBJV4P.png"></a></p><p>指令地址不连续，把0E9h在下方按F2改成0x90，空指令对应机器码，nop，地址连续，然后选中p一下</p><p>就可以生成反汇编代码了</p><p><a href="https://imgse.com/i/piBJe9f"><img src="https://z1.ax1x.com/2023/11/27/piBJe9f.md.jpg" alt="piBJe9f.md.jpg"></a></p><p>逻辑可知得到0，异或回去</p><p>注意把rodata字符串转换成ASCII形式就可以了</p><p><a href="https://imgse.com/i/piBJMuQ"><img src="https://z1.ax1x.com/2023/11/27/piBJMuQ.png" alt="piBJMuQ.png"></a></p>]]></content>
    
    
    
    <tags>
      
      <tag>wp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/12/18/hello-world/"/>
    <url>/2023/12/18/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
